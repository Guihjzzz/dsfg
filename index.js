import { extractStructureFilesFromMcworld as jr } from "mcbe-leveldb-reader";
import ur from "strip-json-comments";
var B = i => document.querySelector(i), Lt = i => document.querySelectorAll(i);
Element.prototype.selectEl = DocumentFragment.prototype.selectEl = function (i) { return this.querySelector(i) };
Element.prototype.selectEls = DocumentFragment.prototype.selectEls = function (i) { return this.querySelectorAll(i) };
Element.prototype.getAllChildren = DocumentFragment.prototype.getAllChildren = function () { let i = [...this.selectEls("*")], e = []; for (; i.length;) { let t = i.shift(); e.push(t), t.shadowRoot && e.push(...t.shadowRoot.selectEls("*")) } return e };
EventTarget.prototype.onEvent = EventTarget.prototype.addEventListener;
EventTarget.prototype.onEvents = function (i, e, t = !1) { i.forEach(r => { this.addEventListener(r, e, t) }) };
EventTarget.prototype.onEventAndNow = function (i, e, t) { e(), this.addEventListener(i, e, t) };
Response.prototype.jsonc = Blob.prototype.jsonc = function () { return new Promise((i, e) => { this.text().then(t => { let r = ur(t), a; try { a = JSON.parse(r) } catch (n) { e(n); return } i(a) }).catch(t => e(t)) }) };
Response.prototype.toImage = async function () { let i = await this.blob(), e = URL.createObjectURL(i), t = new Image; t.src = e; try { await t.decode() } catch { return new Promise((r, a) => { let n = new Image; n.onEvent("load", () => { URL.revokeObjectURL(e), r(n) }), n.onEvent("error", o => { URL.revokeObjectURL(e), a(`Falha ao carregar imagem da resposta com status ${this.status} da URL ${this.url}: ${o}`) }), n.src = e }) } return URL.revokeObjectURL(e), t }; // TRADUÇÃO HOLOLAB
Image.prototype.toImageData = function () { let i = new OffscreenCanvas(this.width, this.height), e = i.getContext("2d"); return e.drawImage(this, 0, 0), e.getImageData(0, 0, i.width, i.height) };
ImageData.prototype.toImage = async function () { let i = new OffscreenCanvas(this.width, this.height); i.getContext("2d").putImageData(this, 0, 0); let t = await i.convertToBlob(), r = URL.createObjectURL(t), a = new Image; a.src = r; try { await a.decode() } catch { return new Promise((n, o) => { let s = new Image; s.onEvent("load", () => { URL.revokeObjectURL(r), n(s) }), s.onEvent("error", u => { URL.revokeObjectURL(r), o(`Falha ao decodificar ImageData com dimensões ${this.width}x${this.height}: ${u}`) }), s.src = r }) } return URL.revokeObjectURL(r), a }; // TRADUÇÃO HOLOLAB
Image.prototype.toBlob = async function () { let i = new OffscreenCanvas(this.width, this.height); return i.getContext("2d").drawImage(this, 0, 0), await i.convertToBlob() };
Image.prototype.setOpacity = async function (i) { let e = this.toImageData(), t = e.data; for (let r = 0; r < t.length; r += 4)t[r + 3] *= i; return await e.toImage() };
Image.prototype.addTint = async function (i) { let e = this.toImageData(), t = e.data; for (let r = 0; r < t.length; r += 4)t[r] *= i[0], t[r + 1] *= i[1], t[r + 2] *= i[2]; return await e.toImage() };
Blob.prototype.toImage = function () { return new Promise((i, e) => { let t = new Image, r = URL.createObjectURL(this); t.onEvent("load", () => { URL.revokeObjectURL(r), i(t) }), t.onEvent("error", a => { URL.revokeObjectURL(r), e(a) }), t.src = r }) };
var Ae = async i => new Promise(e => setTimeout(e, i)), { min: de, max: G, floor: he, ceil: je, sqrt: Gr, round: da, abs: Wr, PI: ne, exp: ha } = Math, ua = (i, e, t) => de(G(i, e), t);
var kt = i => Number.isNaN(i) ? void 0 : i;
function pa(i) { let e = 1 / 0; for (let t = 0; t < i.length; t++)e = e < i[t] ? e : i[t]; return e }
function fa(i, e, t) { return e == null && t == null ? new Array(i + 1).fill().map((r, a) => a) : t == null ? new Array(e - i + 1).fill().map((r, a) => a + i) : new Array((e - i) / t + 1).fill().map((r, a) => a * t + i) }
function ma(i) { return i[~~(Math.random() * i.length)] }
function ga(i) { return i.filter(() => !0) }
function _a(i, e) { let t = [[], []]; return i.forEach(r => { t[+e(r)].push(r) }), t }
function pr(i, e) { let t = {}; return i.forEach(r => { let a = e(r); t[a] ??= [], t[a].push(r) }), t }
function Ea(i) { return pr(i, e => St(e)) }
function va(i) { return Object.freeze(Object.fromEntries(i.map((e, t) => [e, t]))) }
function wa(i) { return Object.freeze(Object.fromEntries(i.map(e => [e, Symbol(e)]))) }
function ue(i) { let [, e, t, r] = i.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i); return [e, t, r].map(a => parseInt(a, 16) / 255) }
function ya(i) { return i + (i % 10 == 1 && i % 100 != 11 ? "st" : i % 10 == 2 && i % 100 != 12 ? "nd" : i % 10 == 3 && i % 100 != 13 ? "rd" : "th") } // Manter em inglês para ordinais, ou adaptar para pt-BR (º, ª)
function xa(i) { return i.includes("/") ? i.slice(0, i.lastIndexOf("/") + 1) : "" }
function St(i) { return i instanceof File && (i = i.name), i.slice(i.lastIndexOf(".") + 1) }
function Ta(i) { return i.includes(".") ? i.slice(0, i.lastIndexOf(".")) : i }
function $t(i, e = "en") { return new Intl.ListFormat(e.replaceAll("_", "-"), { type: "disjunction" }).format(i) }
function ot(i, e) { e.length && (Array.isArray(e) && (e = fr(e)), i.files = e, Rt(i)) }
function De(i, e) { e.length && ot(i, [...i.files, ...e]) }
function fr(i) { let e = new DataTransfer; return i.forEach(t => e.items.add(t)), e.files }
function Rt(i) { i.dispatchEvent(new Event("input", { bubbles: !0 })), i.dispatchEvent(new Event("change", { bubbles: !0 })) }
function Nt(i, e) { let t = e.getBoundingClientRect(); return i.clientY >= t.top && i.clientY <= t.bottom }
function Oa(i) { return new DOMParser().parseFromString(i, "text/html").body.firstElementChild }
function Bt(i, e = "black", t = "white", r = "12px monospace") { let a = new OffscreenCanvas(0, 20), n = a.getContext("2d"); return n.font = r, a.width = n.measureText(i).width, n.fillStyle = t, n.fillRect(0, 0, a.width, a.height), n.fillStyle = e, n.font = r, n.fillText(i, 0, 15), n.getImageData(0, 0, a.width, a.height) }
async function ba(i, e) { let { left: t = 0, right: r = 0, top: a = 0, bottom: n = 0 } = e, o = new OffscreenCanvas(i.width + t + r, i.height + a + n); return o.getContext("2d").drawImage(i, t, a), await (await o.convertToBlob()).toImage() }
async function Ia(...i) { let e = i.map(a => a.width).reduce((a, n) => Pt(a, n)), t = new OffscreenCanvas(e, e), r = t.getContext("2d"); return r.imageSmoothingEnabled = !1, i.forEach(a => { r.drawImage(a, 0, 0, e, e) }), await t.convertToBlob() }
async function Aa(i, e, t = e) { let r = new OffscreenCanvas(e, t), a = r.getContext("2d"); return a.imageSmoothingEnabled = !1, a.drawImage(i, 0, 0, e, t), await r.convertToBlob() }
var Ct = {}; async function st(i) { Ct[i] ??= await fetch(`translations/${i}.json`).then(e => e.jsonc()).catch(() => (console.warn(`Falha ao carregar o idioma ${i} para traduções!`), {})) } // TRADUÇÃO HOLOLAB
function oe(i, e) { if (!(e in Ct)) { console.error(`Idioma ${e} não carregado para tradução!`); return } return Ct[e][i]?.replaceAll(/`([^`]+)`/g, "<code>$1</code>")?.replaceAll(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank">$1</a>') } // TRADUÇÃO HOLOLAB
function pe(i = new Error) { return i.stack.split(`
`).slice(1).removeFalsies() }
async function fe(i) { return new Uint8Array(await crypto.subtle.digest("SHA-256", await i.arrayBuffer())) }
async function Ue(i) { return new Uint8Array(await crypto.subtle.digest("SHA-256", new TextEncoder().encode(i))) }
Uint8Array.prototype.toHexadecimalString = function () { return [...this].map(i => i.toString(16).padStart(2, "0")).join("") };
Array.prototype.removeFalsies = function () { return this.filter(i => i) };
function lt(i, e) { return new File(i, e ?? i.map(t => t.name).join(",")) }
CacheStorage.prototype.clear = async function () { (await this.keys()).forEach(i => this.delete(i)) };
async function me(i) { return await Promise.all(Object.entries(i).map(async ([e, t]) => { i[e] = await t })), i }
function mr(i, e) { for (; e != 0;) { if (!(i >= 1 && e >= 1)) throw new Error(`Não é possível encontrar o MDC de ${i} e ${e}`);[i, e] = [e, i % e] } return i } // TRADUÇÃO HOLOLAB
function Pt(i, e) { return i * e / mr(i, e) }
function Fe(i, e) { let t = document.createElement("a"), r = URL.createObjectURL(i); t.href = r, t.download = e ?? i.name, t.click(), URL.revokeObjectURL(r) }
function Ca(i) { return JSON.stringify(i, (e, t) => typeof t == "bigint" ? (JSON.rawJSON ?? String)(t) : t) }
var ce = class extends Set { #e; constructor() { super(), this.#e = new Map } indexOf(e) { return [...super[Symbol.iterator]()].indexOf(this.#i(e)) } add(e) { let t = this.#i(e); return this.#e.has(t) || this.#e.set(t, structuredClone(e)), super.add(t) } delete(e) { return super.delete(this.#i(e)) } has(e) { return super.has(this.#i(e)) }[Symbol.iterator]() { return this.#e.values() } entries() { let e = this[Symbol.iterator](); return { next: () => { let { value: t, done: r } = e.next(); return { value: r ? void 0 : [t, t], done: r } },[Symbol.iterator]() { return this } } } keys() { return this[Symbol.iterator]() } values() { return this[Symbol.iterator]() } #i(e) { return Ca(e) } }, Me = class extends Map { constructor() { super() } get(e) { return super.get(this.#e(e)) } has(e) { return super.has(this.#e(e)) } set(e, t) { return super.set(this.#e(e), t) } #e(e) { return Ca(e) } }, ie = class i { static URL_PREFIX = "https://cache/"; static BAD_STATUS_CODES = [429]; cacheName;#e;#i; constructor(e, t = "") { return (async () => (this.#i = await caches.open(e), this.#e = t, this.cacheName = e, this))() } async fetch(e) { let t = this.#e + e, r = i.URL_PREFIX + e, a = await this.#i.match(r); if (i.BAD_STATUS_CODES.includes(a?.status) && (await this.#i.delete(r), a = void 0), !a) { a = await this.retrieve(t); let n = 5, o = 1e3; for (; i.BAD_STATUS_CODES.includes(a.status) && n--;)console.debug(`Encontrado status HTTP ruim ${a.status} de ${t}, tentando novamente em ${o}ms`), await Ae(o); n ? await this.#i.put(r, a.clone()) : console.error(`Não foi possível evitar códigos de status HTTP ruins para ${t}`) } return a } async retrieve(e) { let a; for (let n = 0; n < 3; n++)try { return await fetch(e) } catch (o) { if (navigator.onLine && o instanceof TypeError && o.message == "Failed to fetch") console.debug(`Falha ao buscar recurso em ${e}, tentando novamente em 500ms`), a = o, await Ae(500); else throw o } throw console.error(`Falha ao buscar recurso em ${e} após 3 tentativas...`), a } }; // TRADUÇÕES HOLOLAB
function gr(i) { return class extends Error { constructor(e) { super(e), this.name = i } } } var ze = gr("UserError");
import * as $a from "nbtify";
import { ZipWriter as yr, TextReader as xr, BlobWriter as Ra, BlobReader as Na, ZipReader as Tr } from "@zip.js/zip.js";
var He = class { config; textureRefs;#e;#i;#t;#r;#a;#n;#o;#s;#l;#d;#h;#u;#p; constructor(e) { return (async () => { this.config = e, this.textureRefs = new ce; let { blockShapes: t, blockShapeGeos: r, blockStateDefs: a, eigenvariants: n } = await me({ blockShapes: fetch("data/blockShapes.json").then(o => o.jsonc()), blockShapeGeos: fetch("data/blockShapeGeos.json").then(o => o.jsonc()), blockStateDefs: fetch("data/blockStateDefinitions.json").then(o => o.jsonc()), eigenvariants: fetch("data/blockEigenvariants.json").then(o => o.jsonc()) }); return this.#e = t.individual_blocks, this.#i = Object.entries(t.patterns).map(([o, s]) => [new RegExp(o), s]), this.#t = r, this.#r = n, this.#a = a.rotations["*"], this.#n = [], Object.entries(a.rotations.block_shapes ?? {}).forEach(([o, s]) => { o.split(",").forEach(u => { this.#n[u] = s }) }), this.#o = [], this.#s = [], Object.entries(a.rotations.block_names ?? {}).forEach(([o, s]) => { o.startsWith("/") && o.endsWith("/") ? this.#s.push([new RegExp(o.slice(1, -1)), s]) : o.split(",").forEach(u => { this.#o[u] = s }) }), this.#l = a.texture_variants["*"], this.#d = [], Object.entries(a.texture_variants.block_shapes ?? {}).forEach(([o, s]) => { o.split(",").forEach(u => { this.#d[u] = s }) }), this.#h = [], this.#u = [], Object.entries(a.texture_variants.block_names ?? {}).forEach(([o, s]) => { o.startsWith("/") && o.endsWith("/") ? this.#u.push([new RegExp(o.slice(1, -1)), s]) : o.split(",").forEach(u => { this.#h[u] = s }) }), this.#p = new Map, this })() } makeBoneTemplate(e) { let t = e.name, r = this.#c(t), a = this.#f(e, r); a.length == 0 && console.debug(`Nenhum cubo está sendo renderizado para o bloco ${t}`); let n = { cubes: a }; r.includes("{") && (r = r.slice(0, r.indexOf("{"))); let o = this.#n[r], s = this.#o[t]; return this.#g(e).forEach(([l, p]) => { let c = s?.[l] ?? this.#s.find(([d, f]) => d.test(t) && t in f)?.[1] ?? o?.[l] ?? this.#a[l]; if (c) { if (!(p in c)) { console.error(`Valor de estado de bloco ${p} para o estado de bloco de rotação ${l} não encontrado em ${t}...`, e); return } "rotation" in n ? (console.debug(`Múltiplos estados de bloco de rotação para o bloco ${e.name}; adicionando todos juntos!`), n.rotation = n.rotation.map((d, f) => d + c[p][f])) : (n.rotation = c[p], n.pivot = [8, 8, 8]) } }), n.rotation?.every(l => l == 0) && (delete n.rotation, delete n.pivot), n } positionBoneTemplate(e, t) { let r = structuredClone(e); return r.cubes.forEach(a => { a.origin = a.origin.map((n, o) => n + t[o]), "pivot" in a && (a.pivot = a.pivot.map((n, o) => n + t[o])), a.extra_rots?.forEach(n => { n.pivot = n.pivot.map((o, s) => o + t[s]) }) }), "pivot" in r && (r.pivot = r.pivot.map((a, n) => a + t[n])), r } #c(e) { if (this.#p.has(e)) return this.#p.get(e); let t = this.#e[e]; if (t) return t; let a = this.#i.find(([n]) => n.test(e))?.[1] ?? "block"; return this.#p.set(e, a), a } #f(e, t) { let r; t.includes("{") && ([, t, r] = t.match(/^(\w+)\{(textures\/[\w\/]+)\}$/)); let a = structuredClone(this.#t[t]); a || (console.error(`Não foi possível encontrar geometria para a forma de bloco ${t}; usando "block" como padrão`), a = structuredClone(this.#t.block)); let n = [], o = []; for (; a.length;) { let c = a.shift(); if ("block_states" in c) { let d = structuredClone(e); for (let f in c.block_states) typeof c.block_states[f] == "string" && (c.block_states[f] = this.#_(e, c.block_states[f], c)); d.states = { ...d.states, ...c.block_states }, c.block_override = d } if ("if" in c) { if (!this.#x(c.block_override ?? e, c.if)) continue; delete c.if } if ("terrain_texture" in c && (c.terrain_texture = this.#_(c.block_override ?? e, c.terrain_texture, c)), "copy" in c) { if (c.copy == t) { console.error(`Não é possível copiar a mesma forma de bloco: ${t}`); continue } let d = structuredClone(this.#t[c.copy]); d || (console.error(`Não foi possível encontrar geometria para a forma de bloco ${t}; usando "block" como padrão`), d = structuredClone(this.#t.block)); let f = Object.keys(c).filter(h => !["copy", "rot", "pivot", "translate"].includes(h)); d.forEach(h => { "translate" in c && (h.translate = (h.translate ?? [0, 0, 0]).map((g, m) => g + c.translate[m])), f.forEach(g => { if (g == "flip_textures_horizontally" || g == "flip_textures_vertically") { let m = new Set(h[g] ?? []); c[g].forEach(v => { m.has(v) ? m.delete(v) : m.add(v) }), h[g] = [...m] } else typeof h[g] == "object" ? h[g] = { ...c[g], ...h[g] } : h[g] ??= c[g] }), "rot" in c && ("rot" in h ? (h.extra_rots ??= [], h.extra_rots.unshift({ rot: c.rot, pivot: c.pivot ?? [8, 8, 8] })) : (h.rot = c.rot, h.pivot = c.pivot ?? h.pivot)) }), a.push(...d) } else if ("copy_block" in c) { let d = c.copy_block.match(/^entity\.(.+)$/); if (!d) { console.error(`Propriedade copy_block formatada incorretamente: ${d}`); continue } let f = d[1], h = e.block_entity_data?.[f]; if (!h) { console.error(`Não foi possível encontrar a propriedade de entidade de bloco ${f} no bloco ${e.name}:`, e); continue } if (h.name = h.name.replace(/^minecraft:/, ""), this.config.IGNORED_BLOCKS.includes(h.name)) continue; h["#copied_via_copy_block"] = !0; let g = this.#c(h.name), m = this.#f(h, g); "translate" in c && m.forEach(v => { v.origin = v.origin.map((w, x) => w + c.translate[x]), "pivot" in v && (v.pivot = v.pivot.map((w, x) => w + c.translate[x])) }), o.push(...m) } else n.push(c) } n.forEach(c => { Object.defineProperties(c, Object.fromEntries(["x", "y", "z", "w", "h", "d"].map((d, f) => [d, { get() { return (f < 3 ? this.pos : this.size)[f % 3] }, set(h) { (f < 3 ? this.pos : this.size)[f % 3] = h } }])) }); let s = this.#E(n), u = e.name, l = this.#m(e), p; return s.forEach(c => { let d = { origin: c.pos, size: c.size, uv: this.#v(c) }, f = !1; c.w == 0 && (["east", "down", "up", "north", "south"].forEach(m => delete d.uv[m]), f = !0), c.h == 0 && (["west", "east", "up", "north", "south"].forEach(m => delete d.uv[m]), f = !0), c.d == 0 && (["west", "east", "down", "up", "south"].forEach(m => delete d.uv[m]), f = !0); let h; "variant" in c ? h = c.variant : c.ignore_eigenvariant ? "block_override" in c ? h = this.#m(c.block_override, !0) : (p == null && (p = this.#m(e, !0)), h = p) : "block_override" in c ? h = this.#m(c.block_override) : h = l; let g = c.texture_size ?? [16, 16]; for (let m in d.uv) { let v = ["west", "east", "north", "south"].includes(m), w = d.uv[m], x = c.textures?.[m] ?? (v ? c.textures?.side : void 0) ?? c.textures?.["*"] ?? m; if (x == "none") { delete d.uv[m]; continue } x = this.#_(c.block_override ?? e, x, c); let E = { uv: w.uv.map((C, M) => C / g[M]), uv_size: w.uv_size.map((C, M) => C / g[M]), block_name: u, texture_face: x, variant: h, croppable: f }; if (x == "#tex") r ? E.texture_path_override = r : console.error(`Nenhuma #tex para o bloco ${u} e forma de bloco ${t}!`); else if (/^textures\/.+[^/]$/.test(x)) E.texture_path_override = x; else { let C = c.terrain_texture; C && (delete E.block_name, delete E.texture_face, E.terrain_texture_override = C) } if ("texture_path_override" in E && (delete E.block_name, delete E.texture_face, delete E.variant), "tint" in c) { let C = c.tint; if (C = this.#_(c.block_override ?? e, C, c), C[0] == "#") E.tint = ue(C); else { let M = 4294967296 + Number(C); E.tint = [M >> 16 & 255, M >> 8 & 255, M & 255].map(D => D / 255) } } this.textureRefs.add(E); let $ = c.flip_textures_horizontally?.includes(m) ^ (v && c.flip_textures_horizontally?.includes("side")) ^ c.flip_textures_horizontally?.includes("*"), k = c.flip_textures_vertically?.includes(m) ^ (v && c.flip_textures_vertically?.includes("side")) ^ c.flip_textures_vertically?.includes("*"); "box_uv" in c && ($ ^= m != "north" && m != "south", k ^= m == "up"), d.uv[m] = { index: this.textureRefs.indexOf(E), flip_horizontally: (m == "down" || m == "up") ^ $, flip_vertically: (m == "down" || m == "up") ^ k } } "rot" in c && (d.rotation = c.rot, d.pivot = c.pivot ?? [8, 8, 8]), "extra_rots" in c && (d.extra_rots = c.extra_rots), "translate" in c && (d.origin = d.origin.map((m, v) => m + c.translate[v]), "rot" in c && (d.pivot = d.pivot.map((m, v) => m + c.translate[v])), "extra_rots" in c && d.extra_rots.forEach(m => { m.pivot = m.pivot.map((v, w) => v + c.translate[w]) })), d = this.#y(d), o.push(d) }), o } #g(e) { return [...Object.entries(e.states ?? {}), ...Object.entries(e.block_entity_data ?? {}).map(([t, r]) => [`entity.${t}`, r])] } #E(e) { let t = [], r = []; e.forEach(n => { !n.size.some(o => o == 0) && Object.keys(n).length == 2 ? r.push(n) : t.push(n) }); let a = []; return r.forEach(n => { e: for (; ;) { for (let [o, s] of a.entries()) if (this.#w(n, s)) { console.debug("Cubo mesclado", s, "em", n), a.splice(o, 1); continue e } else if (this.#w(s, n)) { console.debug("Cubo mesclado", n, "em", s), a.splice(o, 1), n = s; continue e } break } a.push(n) }), [...t, ...a] } #m(e, t = !1) { let r = e.name, a = r in this.#r; if (!t && a) { let p = this.#r[r]; return console.debug(`Usando eigenvariant ${p} para o bloco ${r}`), p } else t && !a && console.warn(`Não é possível ignorar eigenvariant de ${r} pois não existe!`); if (!("states" in e || "block_entity_data" in e)) return -1; let n = this.#c(r), o = this.#g(e), s = this.#d[n]; if (s?.["#exclusive_add"]) { let p = 0; return o.forEach(([c, d]) => { if (c in s) { let f = s[c]; if (!(d in f)) { console.error(`Valor de estado de bloco ${d} para o estado de bloco de variação de textura ${c} não encontrado em ${r}...`, e); return } p += f[d] } }), p } let u = this.#h[r] ?? this.#u.find(([p]) => p.test(r))?.[1]; if (u?.["#exclusive_add"]) { let p = 0; return o.forEach(([c, d]) => { if (c in u) { let f = u[c]; if (!(d in f)) { console.error(`Valor de estado de bloco ${d} para o estado de bloco de variação de textura ${c} não encontrado...`); return } p += f[d] } }), p } let l = -1; return o.forEach(([p, c]) => { let d = u?.[p] ?? s?.[p] ?? this.#l[p]; if (d == null) return; if (!(c in d)) { console.error(`Valor de estado de bloco ${c} para o estado de bloco de variação de textura ${p} não encontrado...`); return } let f = d[c]; l != -1 && console.warn(`Múltiplos estados de bloco de variação de textura para o bloco ${e.name}; usando ${p}`), l = f }), l } #v(e) { if ("box_uv" in e) { let t = e.box_uv_size ?? e.size, r = { up: { uv: [t[2], 0], uv_size: [t[0], t[2]] }, down: { uv: [t[0] + t[2], 0], uv_size: [t[0], t[2]] }, west: { uv: [0, t[2]], uv_size: [t[2], t[1]] }, north: { uv: [t[2], t[2]], uv_size: [t[0], t[1]] }, east: { uv: [t[0] + t[2], t[2]], uv_size: [t[2], t[1]] }, south: { uv: [t[0] + t[2] * 2, t[2]], uv_size: [t[0], t[1]] } }; return Object.values(r).forEach(a => { a.uv = a.uv.map((n, o) => n + e.box_uv[o]) }), r } else { let t = [e.z, 16 - e.y - e.h], r = [16 - e.z - e.d, 16 - e.y - e.h], a = [16 - e.x - e.w, 16 - e.z - e.d], n = [16 - e.x - e.w, e.z], o = [e.x, 16 - e.y - e.h], s = [16 - e.x - e.w, 16 - e.y - e.h]; return { west: { uv: e.uv?.west ?? e.uv?.side ?? e.uv?.["*"] ?? t, uv_size: e.uv_sizes?.west ?? e.uv_sizes?.side ?? e.uv_sizes?.["*"] ?? [e.d, e.h] }, east: { uv: e.uv?.east ?? e.uv?.side ?? e.uv?.["*"] ?? r, uv_size: e.uv_sizes?.east ?? e.uv_sizes?.side ?? e.uv_sizes?.["*"] ?? [e.d, e.h] }, down: { uv: e.uv?.down ?? e.uv?.["*"] ?? a, uv_size: e.uv_sizes?.down ?? e.uv_sizes?.["*"] ?? [e.w, e.d] }, up: { uv: e.uv?.up ?? e.uv?.["*"] ?? n, uv_size: e.uv_sizes?.up ?? e.uv_sizes?.["*"] ?? [e.w, e.d] }, north: { uv: e.uv?.north ?? e.uv?.side ?? e.uv?.["*"] ?? o, uv_size: e.uv_sizes?.north ?? e.uv_sizes?.side ?? e.uv_sizes?.["*"] ?? [e.w, e.h] }, south: { uv: e.uv?.south ?? e.uv?.side ?? e.uv?.["*"] ?? s, uv_size: e.uv_sizes?.south ?? e.uv_sizes?.side ?? e.uv_sizes?.["*"] ?? [e.w, e.h] } } } } #y(e) { return e.origin = e.origin.map(t => (t - 8) * this.config.SCALE + 8), e.size = e.size.map(t => t * this.config.SCALE), "pivot" in e && (e.pivot = e.pivot.map(t => (t - 8) * this.config.SCALE + 8)), "extra_rots" in e && e.extra_rots.forEach(t => { t.pivot = t.pivot.map(r => (r - 8) * this.config.SCALE + 8) }), e } #x(e, t) { let r = t.replaceAll(/\s/g, ""), a = r.match(/&&|\|\|/g) ?? [], n = r.split(/&&|\|\|/).map(u => { if (u == "#copied_via_copy_block") return e["#copied_via_copy_block"] === !0; if (u == "!#copied_via_copy_block") return e["#copied_via_copy_block"] !== !0; let l = u.match(/^((?:entity\.)?[\w:&-?]+)(==|>|<|>=|<=|!=)(-?\w+)$/); if (!l) return console.error(`Expressão de estado de bloco formatada incorretamente "${u}" da condicional "${t}"\n(Correspondência: ${JSON.stringify(l)})`), !0; let [, p, c, d] = l, f = p.match(/^(entity\.)?([\w:]+)(?:(\?\?|&)(-?\d+))?$/); if (!f) return console.error(`Termo de estado de bloco formado incorretamente: ${p}`), !0; let [, h, g, m, v] = f, w = h ? "block_entity_data" : "states"; if (!(w in e)) return console.error(`Nenhum ${w} no bloco ${e.name}!`), !0; let x = e[w]; if (m != "??" && !(g in x)) return console.error(`Não foi possível encontrar ${w} ${g} no bloco ${e.name}`), !0; let E = x[g]; if (m) { let $ = Number(v); if (Number.isNaN($)) return console.error(`${w} operando ${$} não é um número!`), !0; E = function () { switch (m) { case "&": return E & $; case "??": return E ?? $ } return console.error(`Operador ${w} desconhecido ${m} no termo ${p}!`), E }() } switch (c) { case "==": return E == d; case ">": return E > d; case "<": return E < d; case ">=": return E >= d; case "<=": return E <= d; case "!=": return E != d } return console.error(`Operador de comparação ${w} desconhecido ${c} na expressão ${u}`), !0 }), o = [n[0]]; return a.forEach((u, l) => { u == "&&" ? o[o.length - 1] &&= n[l + 1] : o.push(n[l + 1]) }), o.some(u => u) } #_(e, t, r) { let a, n = t.replaceAll(/\${([^}]+)}/g, (o, s) => { if (a != null) return; if (/^Array\.\w+\[[^\[]+\]$/.test(s)) { let [, f, h] = s.match(/^Array\.(\w+)\[([^\[]+)\]$/), g = r.arrays?.[f]; if (!g) return console.error(`Não foi possível encontrar o array ${f} no cubo:`, r), ""; let m; if (h.startsWith("entity.")) { let v = h.slice(7); if (!("block_entity_data" in e) || !(v in e.block_entity_data)) return console.error(`Não foi possível encontrar a propriedade de entidade de bloco ${v} em ${e.name}:`, e), ""; m = e.block_entity_data[v] } else { if (!("states" in e) || !(h in e.states)) return console.error(`Não foi possível encontrar o estado de bloco ${h} em ${e.name}:`, e), ""; m = e.states[h] } return m in g ? g[m] : (console.error(`Índice do array fora dos limites: ${JSON.stringify(g)}[${m}]`), "") } let u = s.replaceAll(/\s/g, "").match(/^(#block_name|#block_states|#block_entity_data)((?:\.\w+|\[-?\d+\])*)(\[(-?\d+):(-?\d*)\]|\[:(-?\d+)\])?(?:\?\?(.+))?$/); if (!u) return console.error(`Expressão formatada incorretamente: ${o}`), ""; let [, l, p, ...c] = u, d = function () { switch (l) { case "#block_name": return e.name; case "#block_states": return e.states; case "#block_entity_data": return e.block_entity_data } console.error(`Variável especial desconhecida: ${l}`) }(); if (p.match(/\.\w+|\[-?\d+\]/g)?.forEach(f => { let h = f.match(/^\.(\w+)|\[(\d+)\]$/); d = d?.[h[1] ?? h[2]] }), c[0] != null && (d = d?.slice(c[1], c[3] ?? (c[2] == "" ? void 0 : c[2]))), d == null || d == "") if (c[4] != null) { let f = c[4]; if (/SET_WHOLE_STRING\([^)]+\)/.test(f)) { a = f.match(/\(([^)]+)\)/)[1]; return } else d = f } else return console.error(`Nada para ${l}${p} no bloco:`, e), ""; return console.debug(`Alterado ${o} para ${d}!`, e), d }); return a ?? n } #w(e, t) { if (e.x + e.w == t.x) { if (e.y == t.y && e.z == t.z && e.h == t.h && e.d == t.d) return e.w += t.w, !0 } else if (e.y + e.h == t.y) { if (e.x == t.x && e.z == t.z && e.w == t.w && e.d == t.d) return e.h += t.h, !0 } else if (e.z + e.d == t.z && e.x == t.x && e.y == t.y && e.w == t.w && e.h == t.h) return e.d += t.d, !0; return !1 } }; // TRADUÇÕES HOLOLAB (em mensagens de console e erro)
import Er from "tga-js";
import vr from "potpack";
import { all as _r } from "deepmerge";
var Ve = class { hash;#e; constructor(e = [], t = !1) { return (async () => { this.#e = new Map; let r = [], a = [...e].find(u => u.name == "manifest.json"); if (!a) throw new Error("Não foi possível encontrar manifest.json no pacote de recursos local; ele não será carregado!"); this.hash = (await fe(a)).toHexadecimalString(); let n = xa(a.webkitRelativePath), s = [...e].filter(u => u.webkitRelativePath.startsWith(n)).map(u => ({ name: u.webkitRelativePath.slice(n.length), blob: u })); for (let u of s)this.#e.set(u.name, u.blob), t && r.push(u.name, await fe(u.blob)); if (t) this.hash = (await Ue(r.join(`
`))).toHexadecimalString(); else if (!this.hash) { let u = s.map(l => l.name).join(`
`); this.hash = (await Ue(u)).toHexadecimalString(), console.warn(`Não foi possível encontrar manifest.json no pacote de recursos local para hash; usando hash ${this.hash} (isso nunca deveria aparecer)`) } return this })() } getFile(e) { return this.#e.get(e) } }; // TRADUÇÕES HOLOLAB
var La = "v1.21.70.26-preview", ge = class i { static #e = ["blocks.json", "textures/terrain_texture.json", "textures/flipbook_textures.json"]; cacheEnabled; hash; cacheName; hasResourcePacks;#i;#t;#r; constructor(e = [], t = !0, r = La) { return (async () => (this.hash = (await Ue([r, ...e.map(a => a.hash)].join(`
`))).toHexadecimalString(), this.cacheName = `ResourcePackStack_${this.hash}`, this.hasResourcePacks = e.length > 0, this.#i = e, this.#t = await new Ge(r), this.cacheEnabled = t, t && (console.log("Usando cache:", this.cacheName, [r, ...e.map(a => a.hash)]), this.#r = await caches.open(this.cacheName)), this))() } async fetchData(e) { return this.#t.fetch(e) } async fetchResource(e) { let t = `resource_pack/${e}`, r = `https://holoprint-cache/${t}`, a = this.cacheEnabled && await this.#r.match(r); if (ie.BAD_STATUS_CODES.includes(a?.status) && (await this.#r.delete(r), a = void 0), !a) { if (i.#e.includes(e)) { let n = await this.fetchData(t), o = await n.clone().jsonc(), s = await Promise.all(this.#i.map(l => l.getFile(e)?.jsonc())); s.reverse(); let u = [o, ...s.removeFalsies()]; if (u.length == 1) a = n; else { let l = _r(u); console.debug(`Arquivo JSON mesclado ${e}:`, l, "De:", u), a = new Response(JSON.stringify(l)) } } else { for (let n of this.#i) { let o = n.getFile(e); if (o) { a = new Response(o); break } } a ??= await this.fetchData(t) } this.cacheEnabled && await this.#r.put(r, a.clone()) } return a } }, Ge = class i extends ie { static #e = "https://cdn.jsdelivr.net/gh/Mojang/bedrock-samples"; constructor(e = La) { return (async () => (await super(`VanillaDataFetcher_${e}`, `${i.#e}@${e}/`), this.version = e, this))() } }; // TRADUÇÃO HOLOLAB (console.log)
var ye = class i { #e;#i;#t;#r;#a; blocksDotJson; terrainTexture;#n; config; resourcePackStack; textures; imageBlobs; textureWidth; textureHeight; atlasWidth; atlasHeight; textureFillEfficiency; constructor(e, t) { return (async () => { this.config = e, this.resourcePackStack = t; let { blocksDotJson: r, terrainTexture: a, flipbookTextures: n, textureAtlasMappings: o } = await me({ blocksDotJson: this.resourcePackStack.fetchResource("blocks.json").then(s => s.jsonc()), terrainTexture: this.resourcePackStack.fetchResource("textures/terrain_texture.json").then(s => s.jsonc()), flipbookTextures: this.resourcePackStack.fetchResource("textures/flipbook_textures.json").then(s => s.jsonc()), textureAtlasMappings: fetch("data/textureAtlasMappings.json").then(s => s.jsonc()) }); return this.blocksDotJson = r, this.terrainTexture = a, this.#e = o.blocks_dot_json_patches, this.#i = o.blocks_to_use_carried_textures, this.#t = o.transparent_blocks, this.#r = o.terrain_texture_patches, this.#a = o.terrain_texture_tints, this.#n = new Map, o.missing_flipbook_textures.forEach(s => { this.#n.set(s, 1) }), n.map(s => { this.#n.set(s.flipbook_texture, s.replicate ?? 1) }), this })() } async makeAtlas(e) { console.log("Referências de textura:", e); let t = [], r = new ce; e.forEach(o => { let s, u = o.tint, l = !1, p = 1; if ("texture_path_override" in o) s = o.texture_path_override; else { let d = this.#o(o), f = o.block_name, h = o.variant, g = this.#s(d, h); if (s = g.texturePath, u == null && "tint" in g && (u = ue(g.tint)), s || (console.error(`Nenhuma textura para o bloco ${f} na face ${o.texture_face}!`), s = this.#s("missing", -1).texturePath), u == null && d in this.#a.terrain_texture_keys) { let m = this.#a.terrain_texture_keys[d]; typeof m == "object" && (l = m.tint_like_png, m = m.tint), m.startsWith("#") ? u = ue(m) : m in this.#a.colors ? u = ue(this.#a.colors[m]) : console.error(`Nenhuma cor de tintura ${m}`) } f in this.#t && (p = this.#t[f]) } let c = { texturePath: s, tint: u, tint_like_png: l, opacity: p, uv: o.uv, uv_size: o.uv_size, croppable: o.croppable }; r.add(c), t.push(r.indexOf(c)) }), console.log("Índices de imagem de textura:", t), console.log("Fragmentos de textura:", r); let a = await this.#l(r); console.log("Fragmentos de imagem:", a); let n = await this.#d(a); console.log("UVs de imagem:", n), this.textures = t.map(o => n[o]) } #o(e) { if ("terrain_texture_override" in e) return e.terrain_texture_override; let t = e.block_name; !(t in this.blocksDotJson) && t in this.#e && (t = this.#e[t], t?.includes(".") && (e.variant = +t.split(".")[1], t = t.split(".")[0])); let r = this.blocksDotJson[t], a; if (!r) return console.error(`Nenhuma entrada blocks.json para ${t}`), "missing"; let n = e.texture_face; if (n.startsWith("carried")) if ("carried_textures" in r) if (n == "carried") { if (typeof r.carried_textures == "string") return r.carried_textures; console.error(`Textura carregada especificada para ${t} tem múltiplas faces!`) } else { let o = n.slice(8), s = r.carried_textures[o]; if (["west", "east", "north", "south"].includes(o) && (s ??= r.carried_textures.side), o == null) console.error(`Não foi possível encontrar a face da textura carregada ${o}!`); else return s } else console.error(`Nenhuma textura carregada para ${t}!`, e, r); return this.#i.includes(t) && (a = r.carried_textures, console.debug(`Usando texturas carregadas para ${t}`), a || console.error(`Textura carregada especificada em blocks.json para ${t} não pôde ser encontrada`)), a ??= r.textures, a || ("carried_textures" in r ? (a = r.carried_textures, console.error(`Nenhuma entrada de textura encontrada em blocks.json para o bloco ${t}! Usando textura carregada como padrão.`)) : (a = "missing", console.error(`Nenhuma entrada de textura encontrada em blocks.json para o bloco ${t}!`))), typeof a == "string" ? a : a[n] ?? a[["west", "east", "north", "south"].includes(n) ? "side" : function () { let o = Object.keys(a)[0]; return console.error(`Face de textura desconhecida ${n}! Usando ${o} como padrão.`), o }() ] } #s(e, t) { if (e in this.#r) { let a = this.#r[e]; return console.debug(`Chave de textura do terreno ${e} remapeada para o caminho da textura ${a}`), a } let r = this.terrainTexture.texture_data[e]?.textures; if (!r) { console.warn(`Nenhuma entrada terrain_texture.json para a chave ${e}`); return } return Array.isArray(r) && (r.length == 1 ? r = r[0] : (t == -1 && (console.warn(`Variante desconhecida para escolher para a chave de textura do terreno ${e}; usando a primeira como padrão`), t = 0), t in r || (console.error(`Variante ${t} não existe para a chave de textura do terreno ${e}! Usando 0 como padrão.`), t = 0), r = r[t])), typeof r == "string" ? { texturePath: r } : { texturePath: r.path, tint: r.overlay_color ?? r.tint_color } } async #l(e) { let t = new Er, r = [...new Set([...e].map(o => o.texturePath))]; console.log(`Carregando ${r.length} imagens para ${e.size} fragmentos de textura`); let a = await Promise.all(r.map(async o => { let s = await this.resourcePackStack.fetchResource(`${o}.png`), u, l = !1, p = !1; return s.ok ? u = (await s.toImage()).toImageData() : (s = await this.resourcePackStack.fetchResource(`${o}.tga`), s.ok ? (console.debug(`Textura TGA ${o}.tga buscada`), l = !0, t.load(new Uint8Array(await s.arrayBuffer())), u = t.getImageData()) : (console.warn(`Nenhuma textura encontrada em ${o}`), u = Bt(o), p = !0)), { imageData: u, imageIsTga: l, imageNotFound: p } })), n = new Map(r.map((o, s) => [o, a[s]])); return await Promise.all([...e].map(async ({ texturePath: o, tint: s, tint_like_png: u, opacity: l, uv: p, uv_size: c, croppable: d }) => { let { imageData: f, imageIsTga: h, imageNotFound: g } = n.get(o); g && (p = [0, 0], c = [1, 1]), s && (f = this.#p(f, s, h && !u)), l != 1 && (f = this.#c(f, l)); let { width: m, height: v } = f, w = await f.toImage().catch(D => (console.error(`Falha ao decodificar dados de imagem de ${o}: ${D}`), p = [0, 0], c = [1, 1], Bt(`Falha ao decodificar ${o}`).toImage())); if (this.#n.has(o)) { let D = this.#n.get(o); v = m = m / D, console.debug(`Usando textura flipbook para ${o}, ${m}x${v}`) } let x = p[0] * m, E = p[1] * v, $ = c[0] * m, k = c[1] * v, C; if (d) { let D = { sourceX: x, sourceY: E, w: $, h: k }, te = this.#h(w, x, E, $, k); x = te.minX, $ = te.maxX - te.minX + 1, E = te.minY, k = te.maxY - te.minY + 1, C = { x: (x - D.sourceX) / D.w, y: (E - D.sourceY) / D.h, w: $ / D.w, h: k / D.h }, (C.x != 0 || C.y != 0 || C.w != 1 || C.h != 1) && console.debug(`Parte da imagem ${o} cortada para`, C) } let M = { image: w, sourceX: x, sourceY: E, w: $, h: k }; return d && (M.crop = C), M })) } async #d(e) { e.forEach((l, p) => { l.i = p, l.actualSize = [l.w, l.h], l.offset = [0, 0], Number.isInteger(l.sourceX) || (l.offset[0] = l.sourceX % 1, l.w += l.offset[0], l.sourceX = he(l.sourceX)), Number.isInteger(l.sourceY) || (l.offset[1] = l.sourceY % 1, l.h += l.offset[1], l.sourceY = he(l.sourceY)), Number.isInteger(l.w) || (l.w = je(l.w)), Number.isInteger(l.h) || (l.h = je(l.h)) }); let t = e.map(l => ({ ...l })), r = vr(e), a = wr(t), n = r.fill > a.fill ? r : a; a.fill >= r.fill && (e = t), e.sort((l, p) => l.i - p.i), this.textureWidth = n.w, this.textureHeight = n.h, this.textureFillEfficiency = n.fill, this.atlasWidth = this.textureWidth, this.atlasHeight = this.textureHeight, console.info(`Atlas de textura empacotado com ${(this.textureFillEfficiency * 100).toFixed(2)}% de eficiência de espaço!`); let o = new OffscreenCanvas(this.textureWidth, this.textureHeight), s = o.getContext("2d"); console.log("Fragmentos de imagem empacotados:", e); let u = e.map(l => { let p = [l.sourceX, l.sourceY], c = [l.x, l.y], d = [l.w, l.h]; s.drawImage(l.image, ...p, ...d, ...c, ...d); let f = { uv: c.map((h, g) => h + l.offset[g]), uv_size: l.actualSize }; return "crop" in l && (f.crop = l.crop), f }); if (this.config.TEXTURE_OUTLINE_WIDTH != 0 && (o = i.addTextureOutlines(o, e, this.config)), this.config.MULTIPLE_OPACITIES) { let l = fa(4, 10).map(p => p / 10); this.imageBlobs = await Promise.all(l.map(async p => [`hologram_opacity_${p}`, await this.#u(o, p).convertToBlob()])) } else o = this.#u(o, this.config.OPACITY), this.imageBlobs = [["hologram", await o.convertToBlob()]]; return u } #h(e, t = 0, r = 0, a = e.width, n = e.height) { let s = new OffscreenCanvas(a, n).getContext("2d"); s.drawImage(e, t, r, a, n, 0, 0, a, n); let u = s.getImageData(0, 0, a, n).data, l = a, p = n, c = 0, d = 0; for (let f = 0; f < n; f++)for (let h = 0; h < a; h++) { let g = (f * a + h) * 4; u[g + 3] > 0 && (h < l && (l = h), h > c && (c = h), f < p && (p = f), f > d && (d = f)) } return l += t, p += r, c += t, d += r, { minX: l, minY: p, maxX: c, maxY: d } } static addTextureOutlines(e, t, r) { let a = G(1 / r.TEXTURE_OUTLINE_WIDTH, 1), n = new OffscreenCanvas(e.width * a, e.height * a), o = n.getContext("2d"); o.imageSmoothingEnabled = !1, o.drawImage(e, 0, 0, n.width, n.height); let s = e.getContext("2d").getImageData(0, 0, e.width, e.height); o.fillStyle = r.TEXTURE_OUTLINE_COLOR, o.globalAlpha = r.TEXTURE_OUTLINE_OPACITY; let u = "threshold", l = 0, p = (c, d) => u == "difference" ? c - d >= l : d <= l; return t.forEach(({ x: c, y: d, w: f, h }) => { let g = c + f, m = d + h; for (let v = c; v < g; v++)for (let w = d; w < m; w++) { let x = (w * e.width + v) * 4, E = s.data[x + 3]; if (E == 0) continue; let $ = v == c || p(E, s.data[x - 4 + 3]), k = v == g - 1 || p(E, s.data[x + 4 + 3]), C = w == d || p(E, s.data[x - e.width * 4 + 3]), M = w == m - 1 || p(E, s.data[x + e.width * 4 + 3]), D = v == c && w == d || p(E, s.data[x - 4 - e.width * 4 + 3]), te = v == g - 1 && w == d || p(E, s.data[x + 4 - e.width * 4 + 3]), ve = v == c && w == m - 1 || p(E, s.data[x - 4 + e.width * 4 + 3]), qe = v == g - 1 && w == m - 1 || p(E, s.data[x + 4 + e.width * 4 + 3]); $ && o.fillRect(v * a, w * a + 1, 1, a - 2), k && o.fillRect(v * a + a - 1, w * a + 1, 1, a - 2), C && o.fillRect(v * a + 1, w * a, a - 2, 1), M && o.fillRect(v * a + 1, w * a + a - 1, a - 2, 1), (C || $ || D) && o.fillRect(v * a, w * a, 1, 1), (C || k || te) && o.fillRect(v * a + a - 1, w * a, 1, 1), (M || $ || ve) && o.fillRect(v * a, w * a + a - 1, 1, 1), (M || k || qe) && o.fillRect(v * a + a - 1, w * a + a - 1, 1, 1) } }), n } #u(e, t) { let r = new OffscreenCanvas(e.width, e.height), a = r.getContext("2d"); return a.globalAlpha = t, a.drawImage(e, 0, 0), r } #p(e, t, r = !1) { let a = new ImageData(new Uint8ClampedArray(e.data), e.width, e.height), n = a.data; for (let o = 0; o < n.length; o += 4)(!r || n[o + 3] == 255) && (n[o] *= t[0], n[o + 1] *= t[1], n[o + 2] *= t[2]), r && (n[o + 3] = 255); return a } #c(e, t) { let r = new ImageData(new Uint8ClampedArray(e.data), e.width, e.height), a = r.data; for (let n = 0; n < a.length; n += 4)a[n + 3] *= t; return r } }; // TRADUÇÕES HOLOLAB (em mensagens de console e erro)
function wr(i) { let e = 0, t = 0; for (let s of i)e += s.w * s.h, t = Math.max(t, s.w); i.sort((s, u) => u.h - s.h || u.w - s.w); let a = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), t), h: 1 / 0 }], n = 0, o = 0; for (let s of i)for (let u = a.length - 1; u >= 0; u--) { let l = a[u]; if (!(s.w > l.w || s.h > l.h)) { if (s.x = l.x, s.y = l.y, o = Math.max(o, s.y + s.h), n = Math.max(n, s.x + s.w), s.w == l.w && s.h == l.h) { let p = a.pop(); u < a.length && (a[u] = p) } else s.h == l.h ? (l.x += s.w, l.w -= s.w) : s.w == l.w ? (l.y += s.h, l.h -= s.h) : (a.push({ x: l.x + s.w, y: l.y, w: l.w - s.w, h: s.h }), l.y += s.h, l.h -= s.h); break } } return { w: n, h: o, fill: e / (n * o) || 0 } }
var Ce = class { materials; totalMaterialCount;#e;#i;#t;#r;#a;#n;#o;#s;#l;#d;#h;#u; constructor(e, t, r) { return this.materials = new Map, this.totalMaterialCount = 0, this.#e = new Map(e.data_items.map(a => [a.name, a])), this.#i = new Map(t.data_items.map(a => [a.name, a])), r && this.setLanguage(r), (async () => { let a = await fetch("data/materialListMappings.json").then(s => s.jsonc()); this.#r = a.ignored_blocks; let n = Object.entries(a.block_to_item_mappings); this.#a = new Map(n.filter(([s]) => !s.startsWith("/") && !s.endsWith("/"))), this.#n = n.filter(([s]) => s.startsWith("/") && s.endsWith("/")).map(([s, u]) => [new RegExp(s.slice(1, -1), "g"), u]), this.#o = Object.entries(a.item_count_multipliers).map(([s, u]) => { let l = [], p = []; return s.split(",").forEach(c => { c.startsWith("/") && c.endsWith("/") ? p.push(new RegExp(c.slice(1, -1))) : l.push(c) }), typeof u == "number" ? [l, p, u, ""] : [l, p, u.multiplier, u.remove] }), this.#s = a.special_block_entity_properties; let o = Object.entries(a.serialization_id_patches); return this.#l = new Map(o.filter(([s]) => !s.startsWith("/") && !s.endsWith("/"))), this.#d = o.filter(([s]) => s.startsWith("/") && s.endsWith("/")).map(([s, u]) => [new RegExp(s.slice(1, -1), "g"), u]), this.#h = a.blocks_missing_serialization_ids, this.#u = a.translation_patches, this })() } add(e, t = 1) { let r = typeof e == "string" ? e : e.name; if (this.#r.includes(r)) return; let a = this.#a.get(r); if (!a) { let n = this.#n.find(([o]) => o.test(r)); n ? a = r.replaceAll(...n) : a = r } if (this.#o.forEach(([n, o, s, u]) => { (n.includes(a) || o.some(l => l.test(a))) && (t *= s, u != "" && (a = a.replaceAll(u, ""))) }), a in this.#s && typeof e != "string") { let n = this.#s[a].prop; n in (e.block_entity_data ?? {}) ? a += `+${e.block_entity_data[n]}` : console.error(`Não foi possível encontrar a propriedade de entidade de bloco ${n} no bloco ${e.name}!`) } this.materials.set(a, (this.materials.get(a) ?? 0) + t), this.totalMaterialCount += t } addItem(e, t = 1) { this.materials.set(e, (this.materials.get(e) ?? 0) + t), this.totalMaterialCount += t } export() { if (this.#t == null) throw new Error("Não é possível exportar uma lista de materiais sem fornecer traduções! Use setLanguage()"); return [...this.materials].map(([e, t]) => { let r, a; if (e.includes("+")) { let s = e.match(/^([^+]+)\+(\d+)$/); e = s[1], a = +s[2], r = this.#s[e].serialization_ids?.[a] } r ??= this.#h[e] ?? this.#p(e); let n = r && this.#g(r); if (!n) { let s = this.#c(e); n = s && this.#g(s), n ? r = s : (console.warn(!r && !s ? `Não foi possível encontrar nenhuma chave de tradução para ${e}!` : `Não é possível traduzir ${[r, s].removeFalsies().join(" ou ")} para o item "${e}"!`), r ??= s ?? e, n = r) } let o = this.#m(e) ?? this.#v(e); return typeof o == "number" && typeof a == "number" && (o += a), { itemName: e, translationKey: this.#f(r), translatedName: n, count: t, partitionedCount: this.#E(t), auxId: o } }).sort((e, t) => t.count - e.count || e.translatedName > t.translatedName) } setLanguage(e) { this.#t = new Map, e.split(`
`).forEach(t => { let r = t.indexOf("#"); if (r > -1 && (t = t.slice(0, r)), t = t.trim(), t == "") return; let a = t.indexOf("="); this.#t.set(t.slice(0, a), t.slice(a + 1)) }) } clear() { this.materials.clear(), this.totalMaterialCount = 0 } #p(e) { return this.#i.get(`minecraft:${e}`)?.serialization_id } #c(e) { return this.#e.get(`minecraft:${e}`)?.serialization_id } #f(e) { if (this.#l.has(e)) e = this.#l.get(e); else { let t = this.#d.find(([r]) => r.test(e)); t && (e = e.replaceAll(...t)) } return e.endsWith(".name") ? e : `${e}.name` } #g(e) { let t = this.#f(e); return this.#u[t] ?? this.#t.get(t) } #E(e) { if (e < 64) return String(e); { let t = [[he(e / 1728), "\uE200"], [he(e / 64) % 27, "s"], [e % 64, ""]].filter(([r]) => r).map(r => r.join("")); return `${e} = ${t.join(" + ")}` } } #m(e) { return kt(this.#i.get(`minecraft:${e}`)?.raw_id * 65536) } #v(e) { return kt(this.#e.get(`minecraft:${e}`)?.raw_id * 65536) } }; // TRADUÇÕES HOLOLAB (em mensagens de console e erro)
var ct, ka, We = class { viewer; constructor(e, t, r, a, n = !0) { return (async () => { let o = document.createElement("div"); o.classList.add("previewMessage"); let s = document.createElement("p"), u = document.createElement("span"); u.dataset.translate = "preview.loading", s.appendChild(u); let l = document.createElement("div"); l.classList.add("loader"), s.appendChild(l), o.appendChild(s), e.appendChild(o), ct ??= await import("three"), ka ??= (await import("@bridge-editor/model-viewer")).StandaloneModelViewer; let p = document.createElement("canvas"); new MutationObserver(g => { g.forEach(m => { m.attributeName == "style" && p.removeAttribute("style") }) }).observe(p, { attributes: !0 }); let c = t.imageBlobs.at(-1)[1], d = URL.createObjectURL(c); this.viewer = new ka(p, r, d, { width: de(window.innerWidth, window.innerHeight) * .8, height: de(window.innerWidth, window.innerHeight) * .8, antialias: !0, alpha: !n }), this.#e(), n ? await this.#i() : this.viewer.scene.background = null, await this.viewer.loadedModel, URL.revokeObjectURL(d), this.viewer.positionCamera(1.7), this.viewer.camera.far = 5e3, this.viewer.camera.updateProjectionMatrix(), this.viewer.requestRendering(), o.replaceWith(p), this.viewer.controls.minDistance = 10, this.viewer.controls.maxDistance = 1e3; let f = this.viewer.getModel().animator, h = a.animations["animation.armor_stand.hologram.spawn"]; return Object.values(h.bones ?? {}).map(g => Object.values(g).forEach(m => { m.Infinity = m[`${G(...Object.keys(m))}`] })), f.addAnimation("spawn", a.animations["animation.armor_stand.hologram.spawn"]), f.play("spawn"), this })() } #e() { this.viewer.scene.children.shift(); let e = new ct.DirectionalLight(16777215, .5); e.position.set(6, 16, 0), e.target.position.set(-6, 5, 5), this.viewer.scene.add(e), this.viewer.scene.add(e.target); let t = new ct.AmbientLight(16777215, .6); this.viewer.scene.add(t) } async #i() { let e = new ct.CubeTextureLoader; e.setPath("assets/previewPanorama/"); let t = await e.loadAsync([1, 3, 4, 5, 0, 2].map(r => `${r}.png`)); this.viewer.scene.background = t } };
import * as V from "./entityScripts.molang.js";
var _e = class i { static LATEST_VERSION = 18168865; static #e = "https://cdn.jsdelivr.net/gh/SuperLlama88888/BedrockBlockUpgradeSchema"; static #i = "5.1.0+bedrock-1.21.60"; #t;#r;#a; constructor() { this.#t = new ie(`BlockUpgrader@${i.#i}`, `${i.#e}@${i.#i}/`), this.#r = {}, this.#a = new Map } blockNeedsUpdating(e) { return e.version < i.LATEST_VERSION } async update(e) { let t = i.stringifyBlock(e); this.#t instanceof Promise && (this.#t = await this.#t), Object.keys(this.#r).length == 0 && (await this.#t.fetch("schema_list.json").then(o => o.json())).forEach(o => { let s = this.#l(o); this.#r[s] ??= [], this.#r[s].push(o) }); let r = []; Object.entries(this.#r).forEach(([n, o]) => { e.version > n || o.length == 1 && e.version == n || r.push(...o.map(s => s.filename)) }), await Promise.all(r.map(async n => { this.#a.has(n) || this.#a.set(n, await this.#t.fetch(`nbt_upgrade_schema/${n}`).then(o => o.json())) })); let a = !1; return r.forEach(n => { let o = this.#a.get(n); this.#n(o, e) && (a = !0) }), e.version = i.LATEST_VERSION, a && console.debug(`Atualizado ${t} para ${i.stringifyBlock(e)}`), a } #n(e, t) { let r = this.#l(e); if (t.version > r) { console.error(`Tentando atualizar bloco de ${t.version} para ${r}!`); return } if (t.name in (e.flattenedProperties ?? {}) && t.name in (e.renamedIds ?? {})) { console.error(`Não é possível achatar e renomear o bloco ${t.name} ao mesmo tempo: ${JSON.stringify(e)}`); return } if (e.remappedStates?.[t.name]?.some(n => { let o = n.oldState; if (o != null) { if (Object.keys(o).length > Object.keys(t.states).length) return; for (let [u, l] of Object.entries(o)) if (!(u in t.states) || this.#s(l) != t.states[u]) return } "newName" in n ? t.name = n.newName : this.#o(n.newFlattenedName, t); let s = Object.fromEntries(Object.entries(n.newState ?? {}).map(([u, l]) => [u, this.#s(l)])); return n.copiedState?.forEach(u => { u in t.states && (s[u] = t.states[u]) }), t.states = s, !0 })) return t.version = r, !0; let a = !1; return Object.entries(e.addedProperties?.[t.name] ?? {}).forEach(([n, o]) => { let s = this.#s(o); if (n in t.states) { console.debug(`Não é possível adicionar o estado de bloco ${n} = ${s} porque já existe no bloco ${i.stringifyBlock(t)}`); return } t.states[n] = s, a = !0 }), e.removedProperties?.[t.name]?.forEach(n => { if (!(n in t.states)) { console.debug(`Não é possível excluir o estado de bloco ${n} porque não existe no bloco ${i.stringifyBlock(t)}`); return } delete t.states[n], a = !0 }), Object.entries(e.remappedPropertyValues?.[t.name] ?? {}).forEach(([n, o]) => { if (!(n in t.states)) { console.debug(`Não é possível remapear o valor para o estado de bloco ${n} porque o estado não existe: ${i.stringifyBlock(t)}`); return } let s = t.states[n]; if (!(o in e.remappedPropertyValuesIndex)) { console.debug(`Remapeamento de valor de estado de bloco ${o} não encontrado no esquema!`); return } let u = e.remappedPropertyValuesIndex[o], l = u.find(p => s == this.#s(p.old)); if (l == null) { console.debug(`Não foi possível encontrar o valor de estado de bloco ${s} nos remapeamentos para o estado de bloco ${n}: ${JSON.stringify(u)}`); return } t.states[n] = this.#s(l.new), a = !0 }), Object.entries(e.renamedProperties?.[t.name] ?? {}).forEach(([n, o]) => { if (!(n in t.states)) { console.debug(`Não é possível renomear o estado de bloco ${n} -> ${o} porque não existe no bloco ${i.stringifyBlock(t)}`); return } t.states[o] = t.states[n], delete t.states[n], a = !0 }), t.name in (e.flattenedProperties ?? {}) && this.#o(e.flattenedProperties[t.name], t) && (a = !0), t.name in (e.renamedIds ?? {}) && (t.name = e.renamedIds[t.name], a = !0), t.version = r, a } #o(e, t) { let r = e.flattenedProperty; if (!(r in t.states)) { console.debug(`Não é possível achatar o estado de bloco ${r} porque não existe no bloco ${i.stringifyBlock(t)}, ${JSON.stringify(e)}`); return } let a = t.states[r], n = e.flattenedValueRemaps?.[a] ?? a; return t.name = e.prefix + n + e.suffix, delete t.states[r], !0 } #s(e) { return Object.values(e)[0] } #l(e) { return e.maxVersionMajor << 24 | e.maxVersionMinor << 16 | e.maxVersionPatch << 8 | e.maxVersionRevision } static stringifyBlock(e, t = !0) { let r = Object.entries(e.states).map(([n, o]) => `${n}=${o}`).join(","), a = e.name.replace(/^minecraft:/, ""); return r.length && (a += `[${r}]`), t && "version" in e && (a += `@${i.parseBlockVersion(e.version).join(".")}`), a } static parseBlockVersion(e) { return e.toString(16).padStart(8, 0).match(/.{2}/g).map(t => parseInt(t, 16)) } }; // TRADUÇÕES HOLOLAB (em mensagens de console e erro)
var dt = "v1.2.1", Or = ["air", "piston_arm_collision", "sticky_piston_arm_collision"], br = ["Beacon", "Beehive", "Bell", "BrewingStand", "ChiseledBookshelf", "CommandBlock", "Comparator", "Conduit", "EnchantTable", "EndGateway", "JigsawBlock", "Lodestone", "SculkCatalyst", "SculkShrieker", "SculkSensor", "CalibratedSculkSensor", "StructureBlock", "BrushableBlock", "TrialSpawner", "Vault"], Dt = { TOGGLE_RENDERING: "player_controls.toggle_rendering", CHANGE_OPACITY: "player_controls.change_opacity", TOGGLE_TINT: "player_controls.toggle_tint", TOGGLE_VALIDATING: "player_controls.toggle_validating", CHANGE_LAYER: "player_controls.change_layer", DECREASE_LAYER: "player_controls.decrease_layer", CHANGE_LAYER_MODE: "player_controls.change_layer_mode", MOVE_HOLOGRAM: "player_controls.move_hologram", ROTATE_HOLOGRAM: "player_controls.rotate_hologram", CHANGE_STRUCTURE: "player_controls.change_structure", DISABLE_PLAYER_CONTROLS: "player_controls.disable_player_controls", BACKUP_HOLOGRAM: "player_controls.backup_hologram" }, ht = { TOGGLE_RENDERING: J("brick"), CHANGE_OPACITY: J("amethyst_shard"), TOGGLE_TINT: J("white_dye"), TOGGLE_VALIDATING: J("iron_ingot"), CHANGE_LAYER: J("leather"), DECREASE_LAYER: J("feather"), CHANGE_LAYER_MODE: J("flint"), MOVE_HOLOGRAM: J("stick"), ROTATE_HOLOGRAM: J("copper_ingot"), CHANGE_STRUCTURE: J("arrow"), DISABLE_PLAYER_CONTROLS: J("bone"), BACKUP_HOLOGRAM: J("paper") }, Ee = va(["SINGLE", "ALL_BELOW"]);
async function Ut(i, e = {}, t, r) {
    console.info(`Executando HoloLab ${dt}`); // MODIFICADO POR HOLOLAB
    t || (console.debug("Aguardando inicialização da pilha de pacotes de recursos..."), t = await new ge, console.debug("Pilha de pacotes de recursos inicializada!")); // TRADUÇÃO HOLOLAB
    let a = performance.now(); e = Ht(e), Array.isArray(i) || (i = [i]);
    let n = await Promise.all(i.map(y => Ir(y)));
    console.info("Leitura dos NBTs da estrutura finalizada!"); // TRADUÇÃO HOLOLAB
    console.log("NBTs:", n);
    let o = n.map(y => y.size.map(_ => +_)), s = e.PACK_NAME ?? Ft(i),
        u = await Sa({
            packTemplate: { manifest: "manifest.json", hologramRenderControllers: "render_controllers/armor_stand.hologram.render_controllers.json", hologramGeo: "models/entity/armor_stand.hologram.geo.json", hologramMaterial: "materials/entity.material", hologramAnimationControllers: "animation_controllers/armor_stand.hologram.animation_controllers.json", hologramAnimations: "animations/armor_stand.hologram.animation.json", boundingBoxOutlineParticle: "particles/bounding_box_outline.json", blockValidationParticle: "particles/block_validation.json", savingBackupParticle: "particles/saving_backup.json", singleWhitePixelTexture: "textures/particle/single_white_pixel.png", exclamationMarkTexture: "textures/particle/exclamation_mark.png", saveIconTexture: "textures/particle/save_icon.png", itemTexture: e.RETEXTURE_CONTROL_ITEMS ? "textures/item_texture.json" : void 0, terrainTexture: e.RETEXTURE_CONTROL_ITEMS ? "textures/terrain_texture.json" : void 0, hudScreenUI: e.MATERIAL_LIST_ENABLED ? "ui/hud_screen.json" : void 0, customEmojiFont: "font/glyph_E2.png", languagesDotJson: "texts/languages.json" },
            resources: { entityFile: "entity/armor_stand.entity.json", defaultPlayerRenderControllers: e.PLAYER_CONTROLS_ENABLED ? "render_controllers/player.render_controllers.json" : void 0, resourceItemTexture: e.RETEXTURE_CONTROL_ITEMS ? "textures/item_texture.json" : void 0 },
            otherFiles: { // MODIFICADO POR HOLOLAB: packIcon agora busca da URL
                packIcon: fetch("https://github.com/Holo-Lab/holo/blob/main/ChatGPT%20Image%203%20de%20jun.%20de%202025,%2008_40_34.png?raw=true")
                    .then(response => {
                        if (!response.ok) {
                            // TRADUÇÃO HOLOLAB
                            throw new Error(`Falha ao carregar o ícone padrão do HoloLab: ${response.statusText}`);
                        }
                        return response.blob();
                    })
                    .catch(error => {
                        // TRADUÇÃO HOLOLAB
                        console.error("Erro ao carregar pack_icon.png da URL para o HoloLab:", error);
                        // Fallback: gerar um ícone dinâmico se o fetch falhar
                        return Nr(lt(i)); // Nr ainda usa cores que podem precisar de ajuste para o tema azul
                    }),
                itemIcons: e.RETEXTURE_CONTROL_ITEMS ? fetch("data/itemIcons.json").then(y => y.jsonc()) : void 0
            },
            data: { blockMetadata: "metadata/vanilladata_modules/mojang-blocks.json", itemMetadata: "metadata/vanilladata_modules/mojang-items.json" }
        }, t),
        { manifest: l, packIcon: p, entityFile: c, hologramRenderControllers: d, defaultPlayerRenderControllers: f, hologramGeo: h, hologramMaterial: g, hologramAnimationControllers: m, hologramAnimations: v, boundingBoxOutlineParticle: w, blockValidationParticle: x, savingBackupParticle: E, singleWhitePixelTexture: $, exclamationMarkTexture: k, saveIconTexture: C, itemTexture: M, hudScreenUI: D, customEmojiFont: te, languagesDotJson: ve, resourceItemTexture: qe, terrainTexture: Kt, itemIcons: gt } = u.files, { blockMetadata: _t, itemMetadata: qt } = u.data, Zt = (await Sa({ resources: Object.fromEntries(ve.map(y => [y, `texts/${y}.lang`])) }, t)).files, Wa = n.map(y => y.structure), Ya = await Promise.all(Wa.map(y => Ar(y, e.IGNORED_BLOCKS))), { palette: we, indices: Et } = Cr(Ya);
    if (ga(we).length == 0) throw new ze("A estrutura está vazia! Nenhum bloco está dentro da estrutura."); // TRADUÇÃO HOLOLAB
    console.log("paleta combinada: ", we), console.log("índices remapeados: ", Et), window.blockPalette = we, window.blockIndices = Et;
    let Ze = await new He(e), Re = we.map(y => Ze.makeBoneTemplate(y));
    console.info("Modelos de geometria de bloco finalizados!"); // TRADUÇÃO HOLOLAB
    console.log("Criador de geometria de bloco:", Ze), console.log("Paleta de modelo de osso:", structuredClone(Re));
    let W = await new ye(e, t), Ja = [...Ze.textureRefs]; await W.makeAtlas(Ja);
    let Qe = W.imageBlobs, Xa = G(Qe.length - 3, 0);
    console.log("UVs de Textura:", W.textures), Re.forEach(y => { y.cubes.forEach(_ => { Object.keys(_.uv).forEach(b => { let O = _.uv[b], j = structuredClone(W.textures[O.index]); if (O.flip_horizontally && (j.uv[0] += j.uv_size[0], j.uv_size[0] *= -1), O.flip_vertically && (j.uv[1] += j.uv_size[1], j.uv_size[1] *= -1), _.uv[b] = { uv: j.uv, uv_size: j.uv_size }, "crop" in j) { let P = j.crop, K = 1 - P.w - P.x, ae = 1 - P.h - P.y; _.size[0] == 0 ? (_.origin[2] += _.size[2] * (O.flip_horizontally ? K : P.x), _.origin[1] += _.size[1] * (O.flip_vertically ? P.y : ae), _.size[2] *= P.w, _.size[1] *= P.h) : _.size[1] == 0 ? (_.origin[0] += _.size[0] * (O.flip_horizontally ? K : P.x), _.origin[2] += _.size[2] * (O.flip_vertically ? ae : P.y), _.size[0] *= P.w, _.size[2] *= P.h) : _.size[2] == 0 ? (_.origin[0] += _.size[0] * (O.flip_horizontally ? K : P.x), _.origin[1] += _.size[1] * (O.flip_vertically ? P.y : ae), _.size[0] *= P.w, _.size[1] *= P.h) : console.error("Não é possível cortar o modelo de osso sem tamanho zero em um eixo:", y) } }) }) }), console.log("Paleta de modelo de osso com UVs resolvidos:", Re); // TRADUÇÃO HOLOLAB
    let vt = h["minecraft:geometry"][0]; h["minecraft:geometry"].splice(0, 1), vt.description.texture_width = W.atlasWidth, vt.description.texture_height = W.atlasHeight;
    let Ka = Le(o.map(y => y[0]), "v.hologram.structure_index"), qa = Le(o.map(y => y[1]), "v.hologram.structure_index"), Za = Le(o.map(y => y[2]), "v.hologram.structure_index");
    e.SPAWN_ANIMATION_ENABLED || (delete v.animations["animation.armor_stand.hologram.spawn"].loop, delete v.animations["animation.armor_stand.hologram.spawn"].bones);
    let et = m.animation_controllers["controller.animation.armor_stand.hologram.layers"].states, X = G(...o.map(y => y[1])) - 1;
    et.default.transitions.push({ l_0: `v.hologram.layer > -1 && v.hologram.layer != ${X} && v.hologram.layer_mode == ${Ee.SINGLE}` }, { [`l_${X}`]: `v.hologram.layer == ${X} && v.hologram.layer_mode == ${Ee.SINGLE}` }), X > 0 && et.default.transitions.push({ "l_0-": `v.hologram.layer > -1 && v.hologram.layer != ${X - 1} && v.hologram.layer_mode == ${Ee.ALL_BELOW}` }, { [`l_${X - 1}-`]: `v.hologram.layer == ${X - 1} && v.hologram.layer_mode == ${Ee.ALL_BELOW}` });
    let L = c["minecraft:client_entity"].description, wt = 0, Qt = [], ea = [], yt = new Set, Ne = await new Ce(_t, qt);
    Et.forEach((y, _) => {
        let b = o[_], O = `hologram_${_}`, j = `geometry.armor_stand.hologram_${_}`, P = structuredClone(vt); P.description.identifier = j, L.geometry[O] = j, d.render_controllers["controller.render.armor_stand.hologram"].arrays.geometries["Array.geometries"].push(`Geometry.${O}`); let K = [], ae = [], Be, Pe, I, Y = [];
        if (e.SPAWN_ANIMATION_ENABLED) { let T = b.reduce((A, F) => A * F), N = 0; Be = (A, F, S) => { let U = 2 - 1.9 * ha(-.005 * T); return e.SPAWN_ANIMATION_LENGTH * .25 * (b[0] - A + F + b[2] - S + Math.random() * U) }, Pe = A => 1 - (1 - A) ** 3, I = (A, F) => { let S = Number((A + e.SPAWN_ANIMATION_LENGTH).toFixed(2)); N = G(N, S), v.animations["animation.armor_stand.hologram.spawn"].animation_length = N; let U = [0, .2, .4, .6, .8, 1], Q = [-F[0] - 8, -F[1], -F[2] - 8], q = ee => Object.fromEntries(U.map(re => [`${+(A + re * e.SPAWN_ANIMATION_LENGTH).toFixed(2)}`, ee(re)])); return { scale: q(ee => new Array(3).fill(+Pe(ee).toFixed(2))), position: q(ee => Q.map(re => +(re * (1 - Pe(ee))).toFixed(2))) } } } for (let T = 0; T < b[1]; T++) {
            let N = `l_${T}`; P.bones.push({ name: N, parent: "hologram_offset_wrapper", pivot: [8, 0, -8] }), et[N] = { animations: [`hologram.l_${T}`], blend_transition: .1, blend_via_shortest_path: !0, transitions: [{ [T == X ? "default" : `${N}-`]: `v.hologram.layer_mode == ${Ee.ALL_BELOW}` }, { [T == 0 ? "default" : `l_${T - 1}`]: `v.hologram.layer < ${T}${T == X ? " && v.hologram.layer != -1" : ""}` }, T == X ? { default: "v.hologram.layer == -1" } : { [`l_${T + 1}`]: `v.hologram.layer > ${T}` }] }, v.animations[`animation.armor_stand.hologram.l_${T}`] ??= {}; let A = v.animations[`animation.armor_stand.hologram.l_${T}`]; A.loop = "hold_on_last_frame", A.bones ??= {}; for (let S = 0; S < b[1]; S++)S != T && (A.bones[`l_${S}`] = { scale: e.MINI_SCALE }); if (Object.entries(A.bones).length == 0 && delete A.bones, L.animations[`hologram.l_${T}`] = `animation.armor_stand.hologram.l_${T}`, T < X) {
                et[`${N}-`] = { animations: [`hologram.l_${T}-`], blend_transition: .1, blend_via_shortest_path: !0, transitions: [{ [N]: `v.hologram.layer_mode == ${Ee.SINGLE}` }, { [T == 0 ? "default" : `l_${T - 1}-`]: `v.hologram.layer < ${T}${T == X - 1 ? " && v.hologram.layer != -1" : ""}` }, T >= X - 1 ? { default: "v.hologram.layer == -1" } : { [`l_${T + 1}-`]: `v.hologram.layer > ${T}` }] }, v.animations[`animation.armor_stand.hologram.l_${T}-`] ??= {}; let S = v.animations[`animation.armor_stand.hologram.l_${T}-`]; S.loop = "hold_on_last_frame", S.bones ??= {}; for (let U = 0; U < b[1]; U++)U <= T || (S.bones[`l_${U}`] = { scale: e.MINI_SCALE }); Object.entries(S.bones).length == 0 && delete S.bones, L.animations[`hologram.l_${T}-`] = `animation.armor_stand.hologram.l_${T}-`
            } let F = 0; for (let S = 0; S < b[0]; S++)for (let U = 0; U < b[2]; U++) { let Q = (S * b[1] + T) * b[2] + U, q = !0; y.forEach((ee, re) => { let se = ee[Q]; if (!(se in Re)) { se in we && console.error(`Um modelo de osso não foi feito para blockPalette[${se}] = ${we[se].name}!`); return } let cr = Re[se], It = `b_${S}_${T}_${U}`, Ie = It; q || (Ie += `_${re}`), e.SPAWN_ANIMATION_ENABLED && _ == 0 && i.length > 1 && (Ie += "_a"); let tt = [-16 * S - 8, 16 * T, 16 * U - 8], dr = Ze.positionBoneTemplate(cr, tt), at = [{ name: Ie, parent: N, pivot: tt.map(le => le + 8), ...dr }], At = new Me, hr = 0; at[0].cubes = at[0].cubes.filter(le => { if ("extra_rots" in le) { let it = le.extra_rots; if (delete le.extra_rots, !At.has(it)) { let nt = [], sa = Ie; it.forEach(la => { let ca = `${Ie}_rot_wrapper_${hr++}`; nt.push({ name: ca, parent: sa, rotation: la.rot, pivot: la.pivot }), sa = ca }), at.push(...nt), nt.at(-1).cubes = [], At.set(it, nt.at(-1)) } return At.get(it).cubes.push(le), !1 } else return !0 }), P.bones.push(...at), q && (h["minecraft:geometry"][2].bones[1].locators[It] ??= tt.map(le => le + 8)), e.SPAWN_ANIMATION_ENABLED && _ == 0 && Y.push([Ie, Be(S, T, U), tt]); let rt = we[se]; e.IGNORED_MATERIAL_LIST_BLOCKS.includes(rt.name) || Ne.add(rt), re == 0 && (K.push({ locator: It, block: rt.name, pos: [S, T, U] }), F++, yt.add(rt.name)), q = !1, wt++ }) } ae.push(F)
        } if (h["minecraft:geometry"].push(P), e.SPAWN_ANIMATION_ENABLED && _ == 0) { let T = pa(Y.map(([, N]) => N)); Y.forEach(([N, A, F]) => { A -= T - .05, A = Number(A.toFixed(2)), v.animations["animation.armor_stand.hologram.spawn"].bones[N] = I(A, F) }) } Lr(m, _, b), kr(m, _, K, b), Qt.push(K.length), ea.push(ae)
    }), L.materials.hologram = "holoprint_hologram", L.materials["hologram.wrong_block_overlay"] = "holoprint_hologram.wrong_block_overlay", L.textures["hologram.overlay"] = "textures/entity/overlay", L.textures["hologram.save_icon"] = "textures/particle/save_icon", L.animations["hologram.align"] = "animation.armor_stand.hologram.align", L.animations["hologram.offset"] = "animation.armor_stand.hologram.offset", L.animations["hologram.spawn"] = "animation.armor_stand.hologram.spawn", L.animations["hologram.wrong_block_overlay"] = "animation.armor_stand.hologram.wrong_block_overlay", L.animations["controller.hologram.spawn_animation"] = "controller.animation.armor_stand.hologram.spawn_animation", L.animations["controller.hologram.layers"] = "controller.animation.armor_stand.hologram.layers", L.animations["controller.hologram.bounding_box"] = "controller.animation.armor_stand.hologram.bounding_box", L.animations["controller.hologram.block_validation"] = "controller.animation.armor_stand.hologram.block_validation", L.animations["controller.hologram.saving_backup_particles"] = "controller.animation.armor_stand.hologram.saving_backup_particles", L.scripts.animate ??= [], L.scripts.animate.push("hologram.align", "hologram.offset", "hologram.wrong_block_overlay", "controller.hologram.spawn_animation", "controller.hologram.layers", "controller.hologram.bounding_box", "controller.hologram.block_validation", "controller.hologram.saving_backup_particles"), L.scripts.should_update_bones_and_effects_offscreen = !0, L.scripts.initialize ??= [], L.scripts.initialize.push(xe(V.armorStandInitialization, { structureSize: o[0], initialOffset: e.INITIAL_OFFSET, defaultTextureIndex: Xa, singleLayerMode: Ee.SINGLE, structureCount: i.length })), L.scripts.pre_animation ??= [], L.scripts.pre_animation.push(xe(V.armorStandPreAnimation, { textureBlobsCount: Qe.length, totalBlocksToValidate: Le(Qt, "v.hologram.structure_index"), totalBlocksToValidateByLayer: Pr(ea, "v.hologram.structure_index", "v.hologram.layer"), backupSlotCount: e.BACKUP_SLOT_COUNT, structureWMolang: Ka, structureHMolang: qa, structureDMolang: Za, toggleRendering: z(e.CONTROLS.TOGGLE_RENDERING), changeOpacity: z(e.CONTROLS.CHANGE_OPACITY), toggleTint: z(e.CONTROLS.TOGGLE_TINT), toggleValidating: z(e.CONTROLS.TOGGLE_VALIDATING), changeLayer: z(e.CONTROLS.CHANGE_LAYER), decreaseLayer: z(e.CONTROLS.DECREASE_LAYER), changeLayerMode: z(e.CONTROLS.CHANGE_LAYER_MODE), rotateHologram: z(e.CONTROLS.ROTATE_HOLOGRAM), disablePlayerControls: z(e.CONTROLS.DISABLE_PLAYER_CONTROLS), backupHologram: z(e.CONTROLS.BACKUP_HOLOGRAM), singleLayerMode: Ee.SINGLE, ACTIONS: V.ACTIONS })), L.geometry["hologram.wrong_block_overlay"] = "geometry.armor_stand.hologram.wrong_block_overlay", L.geometry["hologram.valid_structure_overlay"] = "geometry.armor_stand.hologram.valid_structure_overlay", L.geometry["hologram.particle_alignment"] = "geometry.armor_stand.hologram.particle_alignment", L.render_controllers ??= [], L.render_controllers.push({ "controller.render.armor_stand.hologram": "v.hologram.rendering" }, { "controller.render.armor_stand.hologram.wrong_block_overlay": "v.hologram.show_wrong_block_overlay" }, { "controller.render.armor_stand.hologram.valid_structure_overlay": "v.hologram.validating && v.wrong_blocks == 0" }, "controller.render.armor_stand.hologram.particle_alignment"), L.particle_effects ??= {}, L.particle_effects.bounding_box_outline = "holoprint:bounding_box_outline", L.particle_effects.saving_backup = "holoprint:saving_backup", Qe.forEach(([y]) => { L.textures[y] = `textures/entity/${y}`, d.render_controllers["controller.render.armor_stand.hologram"].arrays.textures["Array.textures"].push(`Texture.${y}`) }); // "holoprint:" nos identificadores de partícula pode ser mudado se desejar
    let xt = ue(e.TINT_COLOR); d.render_controllers["controller.render.armor_stand.hologram"].overlay_color = { r: +xt[0].toFixed(4), g: +xt[1].toFixed(4), b: +xt[2].toFixed(4), a: `v.hologram.show_tint? ${e.TINT_OPACITY} : 0` };
    let Qa = await $.setOpacity(e.WRONG_BLOCK_OVERLAY_COLOR[3]), er = Ne.totalMaterialCount; yt.forEach(y => { let _ = `validate_${y.replace(":", ".")}`; L.particle_effects[_] = `holoprint:${_}` }); // "holoprint:" aqui também
    let tr = f && Sr(e, f);
    console.log("Contagem de blocos:", Ne.materials); // TRADUÇÃO HOLOLAB
    let ta = Object.fromEntries(ve.map(y => (Ne.setLanguage(Zt[y]), [y, Ne.export()]))), be = ta.en_US;
    console.log("Lista final de materiais:", be); // TRADUÇÃO HOLOLAB
    let aa; if (e.MATERIAL_LIST_ENABLED) { let y = _t.data_items.find(O => O.name == "minecraft:reserved6")?.raw_id ?? 0; D.material_list_entries.controls.push(...be.map(({ translationKey: O, partitionedCount: j, auxId: P }, K) => ({ [`material_list_${K}@hud.material_list_entry`]: { $item_translation_key: O, $item_count: j, $item_id_aux: P ?? y, $background_opacity: K % 2 * .2 } }))), aa = G(...be.map(({ count: O }) => O)); let _ = G(...be.map(({ translatedName: O }) => O.length)), b = G(...be.map(({ partitionedCount: O }) => O.length)); _ + b >= 43 && (D.material_list.size[0] = "50%", D.material_list.max_size[0] = "50%"), D.material_list.size[1] = be.length * 12 + 12, D.material_list_entry.controls[0].content.controls[3].item_name.size[0] += `${da(b * 4.2 + 10)}px` }

    // MODIFICADO POR HOLOLAB: Ajustes no manifest.json (variável 'l')
    l.header.name = s;
    l.header.uuid = crypto.randomUUID();
    let Tt = dt.match(/^v(\d+)\.(\d+)\.(\d+)$/)?.slice(1)?.map(y => +y) ?? [1, 0, 0]; // Tt é a versão da ferramenta
    l.header.version = Tt;

    l.modules[0].description = "§r\nDeveloped by §l§btik§dtok §cGuihjzzz"; // Sua descrição do módulo
    l.modules[0].uuid = crypto.randomUUID();
    l.modules[0].version = Tt;

    l.metadata.authors = ["HoloLab", "§r§cGUIHJZZZ"]; // Autores fixos
    if (e.AUTHORS.length) { // Adiciona autores do formulário, se houver
        l.metadata.authors.push(...e.AUTHORS);
    }
    l.metadata.authors = [...new Set(l.metadata.authors)]; // Remove duplicatas

    l.metadata.generated_with = {
        "HoloLab": [Tt.join(".")] // Gerado com HoloLab versão X.Y.Z
    };
    l.metadata.url = "https://discord.gg/YTdKsTjnUy"; // URL principal para o projeto/comunidade

    l.settings = [ // Limpa settings anteriores e define os seus
        {
            "type": "input",
            "text": "§bTIK§dTOK:",
            "default": "https://www.tiktok.com/@guihjzzz?_t=ZM-8vawBdE0Ew2&_r=1",
            "name": "tiktok_guihjzzz"
        },
        {
            "type": "input",
            "text": "§r§uDISCORD:",
            "default": "https://discord.gg/YTdKsTjnUy",
            "name": "discord_community"
        }
    ];
    // Se você ainda quiser adicionar links da descrição do formulário HTML (e.DESCRIPTION):
    // if (e.DESCRIPTION) {
    // zt(e.DESCRIPTION).forEach(([labelText, linkUrl], index) => {
    // l.settings.push({ type: "input", text: labelText, default: linkUrl, name: `form_link_${index}` });
    // });
    // }
    // FIM DAS MODIFICAÇÕES NO MANIFEST.JSON

    let ra = JSON.stringify(e.CONTROLS) != JSON.stringify(ht), ia = e.RENAME_CONTROL_ITEMS || e.RETEXTURE_CONTROL_ITEMS ? await Vt() : void 0, na = e.RENAME_CONTROL_ITEMS || e.RETEXTURE_CONTROL_ITEMS ? await ia.fetch("item_tags.json").then(y => y.json()) : void 0, { inGameControls: ar, controlItemTranslations: rr } = ra || e.RENAME_CONTROL_ITEMS ? await Rr(e, _t, qt, ve, Zt, na) : {}, ir = new Date().toLocaleString(), nr = { SPAWN_ANIMATION_ENABLED: "spawn_animation_disabled", PLAYER_CONTROLS_ENABLED: "player_controls_disabled", MATERIAL_LIST_ENABLED: "material_list_disabled", RETEXTURE_CONTROL_ITEMS: "retextured_control_items_disabled", RENAME_CONTROL_ITEMS: "renamed_control_items_disabled" },
        or = await Promise.all(ve.map(async y => { // ve é a lista de idiomas, ex: ["en_US", "pt_BR"]
            let _ = (await fetch(`packTemplate/texts/${y}.lang`).then(O => O.text())).replaceAll(/\r\n/g, "\n");
            _ = _.replaceAll("{PACK_NAME}", s);
            _ = _.replaceAll("{PACK_GENERATION_TIME}", ir);
            _ = _.replaceAll("{TOTAL_MATERIAL_COUNT}", er);
            _ = _.replaceAll("{MATERIAL_LIST}", ta[y].map(({ translatedName: O, count: j }) => `${j} ${O}`).join(", "));

            e.AUTHORS.length ? (_ = _.replaceAll(/\{STRUCTURE_AUTHORS\[([^)]+)\]\}/g, (O, j) => e.AUTHORS.join(j)), _ = _.replaceAll("{AUTHORS_SECTION}", _.match(/pack\.description\.authors=([^\t#\n]+)/)?.[1] ?? "")) : _ = _.replaceAll("{AUTHORS_SECTION}", "");
            e.DESCRIPTION ? (_ = _.replaceAll("{DESCRIPTION}", e.DESCRIPTION.replaceAll(`\n`, "\\n")), _ = _.replaceAll("{DESCRIPTION_SECTION}", _.match(/pack\.description\.description=([^\t#\n]+)/)?.[1] ?? "")) : _ = _.replaceAll("{DESCRIPTION_SECTION}", "");

            let b = Object.entries(nr).filter(([O]) => !e[O]).map(([O, j]) => _.match(new RegExp(`pack\\.description\\.${j}=([^\\t#\\n]+)`))?.[1]).filter(Boolean).join("\\n");
            b ? (_ = _.replaceAll("{DISABLED_FEATURES}", b), _ = _.replaceAll("{DISABLED_FEATURES_SECTION}", _.match(/pack\.description\.disabled_features=([^\t#\n]+)/)?.[1] ?? "")) : _ = _.replaceAll("{DISABLED_FEATURES_SECTION}", "");

            ra ? (_ = _.replaceAll("{CONTROLS}", ar[y].replaceAll(`\n`, "\\n")), _ = _.replaceAll("{CONTROLS_SECTION}", _.match(/pack\.description\.controls=([^\t#\\n]+)/)?.[1] ?? "")) : _ = _.replaceAll("{CONTROLS_SECTION}", "");

            _ = _.replaceAll(/pack\.description\..+\s*/g, ""); // Remove as chaves pack.description.* originais do template
            _ = _.replaceAll(/\t*#.+/g, ""); // Remove comentários

            // MODIFICADO POR HOLOLAB: Adiciona sua descrição personalizada aos arquivos .lang
            _ += "\npack.description=§r\\nDeveloped by §l§btik§dtok §cGuihjzzz§r\n";

            e.RENAME_CONTROL_ITEMS && (_ += rr[y]);
            return [y, _]
        })),
        oa = !1, Ot = [];
    if (e.RETEXTURE_CONTROL_ITEMS) {
        let y, _, b = Object.entries(gt).filter(([O]) => O.startsWith("/") && O.endsWith("/")).map(([O, j]) => [new RegExp(O.slice(1, -1), "g"), j]);
        await Promise.all(Object.entries(e.CONTROLS).map(async ([O, j]) => {
            // TRADUÇÃO HOLOLAB (mensagens de console)
            let P = `textures/items/~${O.toLowerCase()}.png`, K = await fetch(`packTemplate/${P}`).then(I => I.toImage()), ae = await ba(K, { right: 16, bottom: 16 }), Be = new Set, Pe = Br(j, na);
            await Promise.all(Pe.map(async I => {
                if (I in gt) I = gt[I]; else { let A = b.find(([F]) => F.test(I)); A && (I = I.replaceAll(...A)) }
                let Y = -1; if (I.includes(".")) { let A = I.indexOf("."); Y = +I.slice(A + 1), I = I.slice(0, A) }
                let T = !1, N = qe.texture_data[I]?.textures;
                if (N) Array.isArray(N) && N.length == 1 && (Y = 0);
                else if (I in W.blocksDotJson)
                    if (typeof W.blocksDotJson[I].carried_textures == "string" && W.terrainTexture.texture_data[W.blocksDotJson[I].carried_textures].textures.startsWith?.("textures/items/")) oa = !0, T = !0, N = W.terrainTexture.texture_data[W.blocksDotJson[I].carried_textures].textures, I = W.blocksDotJson[I].carried_textures;
                    else { console.warn(`Não é possível retexturizar o item de controle "${I}" porque é um bloco, e a retexturização de itens de bloco não é atualmente suportada.`); return }
                else {
                    _ ??= new Promise(async (S, U) => { try { y = new Map; let Q = await ia.fetch("r16_to_current_item_map.json").then(q => q.json()); Object.entries(Q.simple).forEach(([q, ee]) => { y.set(ee.slice(10), [q.slice(10), -1]) }), Object.entries(Q.complex).forEach(([q, ee]) => { Object.entries(ee).forEach(([re, se]) => { y.set(se.slice(10), [q.slice(10), re]) }) }), S() } catch (Q) { U(Q) } });
                    try { await _ } catch (S) { console.error("Falha ao carregar mapeamentos de itens legados. Por favor, reporte isso no GitHub!", S); return }
                    if (!y.has(I)) { console.warn(`Não foi possível encontrar a textura do item de controle para ${I}`); return }
                    let [A, F] = y.get(I); if (Y = F, N = qe.texture_data[A]?.textures, !N) { console.warn(`Não foi possível encontrar a textura do item de controle para ${I} (${A})`); return } I = A
                }
                if (Array.isArray(N)) {
                    if (Y == -1) { console.warn(`Não sei qual textura usar para a textura do item de controle para ${I}: [${N}]`); return }
                    if (!(Y in N)) { console.error(`Variante de textura de item ${Y} para ${I} não existe!`); return }
                    M.texture_data[I] ??= { textures: [...N] }; let A = `${M.texture_data[I].textures[Y]}.png`, F;
                    try { F = await t.fetchResource(A).then(Q => Q.toImage()) } catch { console.warn(`Falha ao carregar a textura ${A} para retexturização do item de controle!`); return }
                    let S = await Ia(F, ae), U = `${A.slice(0, -4)}_${O.toLowerCase()}.png`; Ot.push([U, S]), M.texture_data[I].textures[Y] = U.slice(0, -4), console.debug(`Textura de controle sobreposta para ${O} em ${A}`)
                } else {
                    let A = 16; if (t.hasResourcePacks) try { A = (await t.fetchResource(`${N}.png`).then(U => U.toImage())).width } catch (S) { console.warn(`Não foi possível carregar a textura do item ${N} para cálculos de escala da textura de sobreposição!`, S) }
                    let F = Pt(ae.width, A) * e.CONTROL_ITEM_TEXTURE_SCALE; Be.add(F), (T ? Kt : M).texture_data[I] = { textures: [N, `${P.slice(0, -4)}_${F}`], additive: !0 }
                }
            }))
            await Promise.all([...Be].map(async I => { let Y = `${P.slice(0, -4)}_${I}.png`, T = await Aa(ae, I); Ot.push([Y, T]) }))
        }))
    }
    console.info("Todos os arquivos do pacote finalizados!"); // TRADUÇÃO HOLOLAB
    let sr = new Ra, bt = new yr(sr), R = [];
    i.length == 1 ? R.push([".mcstructure", i[0], i[0].name]) : R.push(...i.map((y, _) => [`${_}.mcstructure`, y, y.name])),
        R.push(["manifest.json", JSON.stringify(l)]), R.push(["pack_icon.png", p]),
        R.push(["entity/armor_stand.entity.json", JSON.stringify(c).replaceAll("HOLOGRAM_INITIAL_ACTIVATION", !0)]),
        R.push(["subpacks/punch_to_activate/entity/armor_stand.entity.json", JSON.stringify(c).replaceAll("HOLOGRAM_INITIAL_ACTIVATION", !1)]),
        R.push(["render_controllers/armor_stand.hologram.render_controllers.json", JSON.stringify(d)]),
        e.PLAYER_CONTROLS_ENABLED && R.push(["render_controllers/player.render_controllers.json", JSON.stringify(tr)]),
        R.push(["models/entity/armor_stand.hologram.geo.json", Mr(h)]),
        R.push(["materials/entity.material", JSON.stringify(g)]),
        R.push(["animation_controllers/armor_stand.hologram.animation_controllers.json", JSON.stringify(m)]),
        R.push(["particles/bounding_box_outline.json", JSON.stringify(w)]),
        yt.forEach(y => { let _ = `validate_${y.replace(":", ".")}`, b = structuredClone(x); b.particle_effect.description.identifier = `holoprint:${_}`, b.particle_effect.components["minecraft:particle_expire_if_in_blocks"] = [y.includes(":") ? y : `minecraft:${y}`], R.push([`particles/${_}.json`, JSON.stringify(b)]) }), // "holoprint:"
        R.push(["particles/saving_backup.json", JSON.stringify(E)]),
        R.push(["textures/particle/single_white_pixel.png", await $.toBlob()]),
        R.push(["textures/particle/exclamation_mark.png", await k.toBlob()]),
        R.push(["textures/particle/save_icon.png", await C.toBlob()]),
        R.push(["textures/entity/overlay.png", await Qa.toBlob()]),
        R.push(["animations/armor_stand.hologram.animation.json", JSON.stringify(v)]),
        Qe.forEach(([y, _]) => { R.push([`textures/entity/${y}.png`, _]) }),
        e.RETEXTURE_CONTROL_ITEMS && (R.push(["textures/item_texture.json", JSON.stringify(M)]), oa && R.push(["textures/terrain_texture.json", JSON.stringify(Kt)]), R.push(...Ot)),
        e.MATERIAL_LIST_ENABLED && (R.push(["ui/hud_screen.json", JSON.stringify(D)]), aa >= 1728 && R.push(["font/glyph_E2.png", await te.toBlob()])),
        R.push(["texts/languages.json", JSON.stringify(ve)]),
        or.forEach(([y, _]) => { R.push([`texts/${y}.lang`, _]) }),
        await Promise.all(R.map(([y, _, b]) => { let O = { comment: b, level: e.COMPRESSION_LEVEL }; return _ instanceof Blob ? bt.add(y, new Na(_), O) : bt.add(y, new xr(_), O) }));
    let lr = await bt.close();
    // TRADUÇÃO HOLOLAB
    console.info(`Criação do pacote finalizada em ${(performance.now() - a).toFixed(0) / 1e3}s!`);
    if (r) {
        let y = () => {
            h["minecraft:geometry"].filter(_ => _.description.identifier.startsWith("geometry.armor_stand.hologram_")).map(_ => {
                // TRADUÇÃO HOLOLAB (erro no console)
                new We(r, W, _, v, e.SHOW_PREVIEW_SKYBOX).catch(b => console.error("Erro no renderizador de preview:", b))
            })
        };
        if (wt < e.PREVIEW_BLOCK_LIMIT) y(); else {
            let _ = document.createElement("div");
            _.classList.add("previewMessage", "clickToView");
            let b = document.createElement("p");
            b.dataset.translationSubTotalBlockCount = wt, i.length == 1 ? b.dataset.translate = "preview.click_to_view" : b.dataset.translate = "preview.click_to_view_multiple", _.appendChild(b), _.onEvent("click", () => { _.remove(), y() }), r.appendChild(_)
        }
    } return new File([lr], `${s}.hololab.mcpack`, { type: "application/mcpack" }) // MODIFICADO POR HOLOLAB: .hololab.mcpack
}
async function Ba(i) {
    let e = new Na(i), t = new Tr(e), r = (await t.getEntries()).filter(o => o.filename.endsWith(".mcstructure")); t.close();
    let a = await Promise.all(r.map(o => o.getData(new Ra))), n = i.name.slice(0, i.name.indexOf("."));
    return a.length == 1 ? [new File([a[0]], r[0].comment || `${n}.mcstructure`)] : await Promise.all(a.map(async (o, s) => new File([o], r[s].comment || `${n}_${s}.mcstructure`)))
}
function Ft(i) { let e = i.map(t => t.name.replace(/(\.holoprint)?\.[^.]+$/, "")).join(", "); return e.length > 40 && (e = `${e.slice(0, 19)}...${e.slice(-19)}`), e.trim() == "" && (e = "holograma"), e } // MODIFICADO POR HOLOLAB: holoprint -> hololab (ou remover se o nome do pack agora é sempre 'holograma')
// TRADUÇÃO HOLOLAB (placeholder "holograma")
function zt(i) { let e = []; return Array.from(i.matchAll(/(.*?)\n?\s*(https?:\/\/[^\s]+)/g)).forEach(t => { let r = t[1].trim(), a = t[2].trim(); e.push([r, a]) }), e }
function J(i, e = []) { return Array.isArray(i) || (i = [i]), Array.isArray(e) || (e = [e]), { names: i, tags: e } }
function Ht(i) { return Object.freeze({ IGNORED_BLOCKS: [], IGNORED_MATERIAL_LIST_BLOCKS: [], SCALE: .95, OPACITY: .9, MULTIPLE_OPACITIES: !0, TINT_COLOR: "#007bff", TINT_OPACITY: .2, MINI_SCALE: .125, TEXTURE_OUTLINE_WIDTH: .25, TEXTURE_OUTLINE_COLOR: "#0056b3", TEXTURE_OUTLINE_OPACITY: .65, SPAWN_ANIMATION_ENABLED: !0, SPAWN_ANIMATION_LENGTH: .4, PLAYER_CONTROLS_ENABLED: !0, CONTROLS: {}, MATERIAL_LIST_ENABLED: !0, RETEXTURE_CONTROL_ITEMS: !0, CONTROL_ITEM_TEXTURE_SCALE: 1, RENAME_CONTROL_ITEMS: !0, WRONG_BLOCK_OVERLAY_COLOR: [1, 0, 0, .3], INITIAL_OFFSET: [0, 0, 0], BACKUP_SLOT_COUNT: 10, PACK_NAME: void 0, PACK_ICON_BLOB: void 0, AUTHORS: [], DESCRIPTION: void 0, COMPRESSION_LEVEL: 5, PREVIEW_BLOCK_LIMIT: 500, SHOW_PREVIEW_SKYBOX: !0, ...i, IGNORED_BLOCKS: Or.concat(i.IGNORED_BLOCKS ?? []), CONTROLS: { ...ht, ...i.CONTROLS } }) } // MODIFICADO POR HOLOLAB: Cores padrão de TINT e OUTLINE para azuis
async function Vt() { let i = "4.1.0+bedrock-1.21.70"; return await new ie(`BedrockData@${i}`, `https://cdn.jsdelivr.net/gh/pmmp/BedrockData@${i}/`) }
async function Ir(i) {
    // TRADUÇÃO HOLOLAB
    if (i.size == 0) throw new ze(`"${i.name}" é um arquivo vazio! Por favor, tente exportar sua estrutura novamente.\nSe você joga em uma versão abaixo da 1.20.50, exportar para o OneDrive fará com que seu arquivo de estrutura fique vazio.`);
    let e = await i.arrayBuffer().catch(r => { throw new Error(`Não foi possível ler o conteúdo do arquivo de estrutura "${i.name}"!\n${r}`) });
    return (await $a.read(e).catch(r => { throw new Error(`NBT inválido no arquivo de estrutura "${i.name}"!\n${r}`) })).data
}
async function Sa(i, e) { let t = {}; Object.entries(i.packTemplate ?? {}).forEach(([a, n]) => { t[a] = n && Mt(fetch(`packTemplate/${n}`), n) }), Object.entries(i.resources ?? {}).forEach(([a, n]) => { t[a] = n && Mt(e.fetchResource(n), n) }), Object.assign(t, i.otherFiles ?? {}); let r = {}; return Object.entries(i.data ?? {}).forEach(([a, n]) => { r[a] = n && Mt(e.fetchData(n), n) }), await me({ files: me(t), data: me(r) }) }
async function Mt(i, e) {
    let t = await i;
    // TRADUÇÃO HOLOLAB
    if (t.status >= 400) throw new Error(`Erro HTTP ${t.status} para ${t.url}`);
    switch (St(e)) { case "json": case "material": return await t.jsonc(); case "lang": return await t.text(); case "png": return await t.toImage() } return await t.blob()
}
async function Ar(i, e) {
    let t = structuredClone(i.palette.default.block_palette), r = new Set, a = new _e(!0), n = 0; for (let [c, d] of Object.entries(t)) { if (r.add(+d.version), a.blockNeedsUpdating(d) && await a.update(d) && n++, d.name = d.name.replace(/^minecraft:/, ""), e.includes(d.name)) { delete t[c]; continue } delete d.version, Object.keys(d.states).length || delete d.states } let o = [...r].map(c => _e.parseBlockVersion(c).join("."));
    // TRADUÇÃO HOLOLAB
    n > 0 && (console.info(`Atualizados ${n} bloco${n > 1 ? "s" : ""} de ${o.join(", ")} para ${_e.parseBlockVersion(_e.LATEST_VERSION).join(".")}!`), console.info("Nota: Blocos atualizados podem não ser 100% precisos! Se houver alguns erros, tente carregar a estrutura na versão mais recente do Minecraft e salvá-la novamente, para que todos os blocos estejam atualizados.")), console.log("Versões de bloco:", [...r], o);
    let s = i.block_indices.map(c => structuredClone(c).map(d => +d)), u = new Me, l = new Set, p = i.palette.default.block_position_data; for (let c in p) { let d = s[0][c]; if (!(d in t) || !("block_entity_data" in p[c])) continue; let f = structuredClone(p[c].block_entity_data); if (br.includes(f.id)) continue; delete f.x, delete f.y, delete f.z; let h = structuredClone(t[d]); if (h.block_entity_data = f, u.has(h)) s[0][c] = u.get(h); else { let g = t.length; t[g] = h, s[0][c] = g, u.set(h, g), l.add(d) } } for (let c of l) delete t[c]; return { palette: t, indices: s }
}
function Cr(i) { if (i.length == 1) return { palette: i[0].palette, indices: [i[0].indices] }; let e = new ce, t = []; return i.forEach(({ palette: r, indices: a }) => { let n = []; r.forEach((o, s) => { e.add(o), n[s] = e.indexOf(o) }), t.push(a.map(o => o.map(s => n[s] ?? -1))) }), { palette: [...e], indices: t } }
function Lr(i, e, t) { let r = [`v.size = ${t[0] / 2}; v.dir = 0; v.r = 1; v.g = 0; v.b = 0;`, `v.size = ${t[1] / 2}; v.dir = 1; v.r = 1 / 255; v.g = 1; v.b = 0;`, `v.size = ${t[2] / 2}; v.dir = 2; v.r = 0; v.g = 162 / 255; v.b = 1;`, `v.size = ${t[0] / 2}; v.dir = 0; v.y = ${t[1]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[0] / 2}; v.dir = 0; v.z = ${t[2]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[0] / 2}; v.dir = 0; v.y = ${t[1]}; v.z = ${t[2]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[1] / 2}; v.dir = 1; v.x = ${t[0]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[1] / 2}; v.dir = 1; v.z = ${t[2]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[1] / 2}; v.dir = 1; v.x = ${t[0]}; v.z = ${t[2]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[2] / 2}; v.dir = 2; v.x = ${t[0]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[2] / 2}; v.dir = 2; v.y = ${t[1]}; v.r = 1; v.g = 1; v.b = 1;`, `v.size = ${t[2] / 2}; v.dir = 2; v.x = ${t[0]}; v.y = ${t[1]}; v.r = 1; v.g = 1; v.b = 1;`], a = { particle_effects: [], transitions: [{ hidden: `!v.hologram.rendering || v.hologram.structure_index != ${e}` }] }; r.forEach(o => { a.particle_effects.push({ effect: "bounding_box_outline", locator: "hologram_root", pre_effect_script: o.replaceAll(/\s/g, "") }) }); let n = `visible_${e}`; i.animation_controllers["controller.animation.armor_stand.hologram.bounding_box"].states[n] = a, i.animation_controllers["controller.animation.armor_stand.hologram.bounding_box"].states.hidden.transitions.push({ [n]: `v.hologram.rendering && v.hologram.structure_index == ${e}` }) }
function kr(i, e, t, r) { let a = { particle_effects: [], transitions: [{ default: "!v.hologram.validating" }] }, n = `validate_${e}`, o = i.animation_controllers["controller.animation.armor_stand.hologram.block_validation"].states; o[n] = a; let s = { [n]: `v.hologram.validating && v.hologram.structure_index == ${e} && v.hologram.layer == -1` }; o.default.transitions.push(s); let u = []; t.forEach(l => { let [p, c, d] = l.pos, f = `validate_${e}_l_${c}`; if (!(f in o)) { let g = { particle_effects: [], transitions: [{ default: "!v.hologram.validating" }, s] }; u.forEach(m => { g.transitions.push({ [`validate_${e}_l_${m}`]: `v.hologram.validating && v.hologram.structure_index == ${e} && v.hologram.layer == ${m}` }) }), Object.values(o).forEach(m => { m.transitions.push({ [f]: `v.hologram.validating && v.hologram.structure_index == ${e} && v.hologram.layer == ${c}` }) }), o[f] = g, u.push(c) } let h = { effect: `validate_${l.block.replace(":", ".")}`, locator: l.locator, pre_effect_script: `
				v.x = ${p};
				v.y = ${c};
				v.z = ${d};
			`.replaceAll(/\s/g, "") }; a.particle_effects.push(h), o[f].particle_effects.push(h) }); for (let l = 0; l < r[1]; l++)u.includes(l) || Object.entries(o).forEach(([p, c]) => { p.startsWith(`validate_${e}`) && (c.transitions[0].default += ` || v.hologram.layer == ${l}`) }) }
function Sr(i, e) { let t = xe(V.playerInitVariables), r = xe(V.playerRenderingControls, { toggleRendering: z(i.CONTROLS.TOGGLE_RENDERING), changeOpacity: z(i.CONTROLS.CHANGE_OPACITY), toggleTint: z(i.CONTROLS.TOGGLE_TINT), toggleValidating: z(i.CONTROLS.TOGGLE_VALIDATING), changeLayer: z(i.CONTROLS.CHANGE_LAYER), decreaseLayer: z(i.CONTROLS.DECREASE_LAYER), changeLayerMode: z(i.CONTROLS.CHANGE_LAYER_MODE), moveHologram: z(i.CONTROLS.MOVE_HOLOGRAM), rotateHologram: z(i.CONTROLS.ROTATE_HOLOGRAM), changeStructure: z(i.CONTROLS.CHANGE_STRUCTURE), backupHologram: z(i.CONTROLS.BACKUP_HOLOGRAM), ACTIONS: V.ACTIONS }), a = xe(V.playerBroadcastActions, { backupSlotCount: i.BACKUP_SLOT_COUNT }); return $r(e, { "controller.render.player.first_person": xe(V.playerFirstPerson, { initVariables: t, renderingControls: r, broadcastActions: a }), "controller.render.player.third_person": xe(V.playerThirdPerson, { initVariables: t, renderingControls: r, broadcastActions: a }) }) }
function $r(i, e) { return { format_version: i.format_version, render_controllers: Object.fromEntries(Object.entries(e).map(([t, r]) => { let a = i.render_controllers[t]; if (!a) { console.error(`Nenhum controlador de renderização ${t} encontrado!`, i); return } let n = a.textures[0]; return r = r.replace(/\n|\t/g, ""), n.endsWith(";") ? r += n : r += `return ${n};`, [t, { ...a, textures: [r, ...a.textures.slice(1)] }] }).removeFalsies()) } } // TRADUÇÃO HOLOLAB
async function Rr(i, e, t, r, a, n) { let o = await new Ce(e, t), s = {}, u = {}; return await Promise.all(r.map(l => st(l))), r.forEach(l => { s[l] = ""; let p = {}, c = {}, d = {}; Object.entries(i.CONTROLS).forEach(([f, h]) => { o.clear(), o.setLanguage(a[l]), h.names.forEach(w => o.addItem(w)); let g = o.export(), m = oe(Dt[f], l); p[f] = m, s[l] += `
${m}: ${[g.map(w => `\xA73${w.translatedName}\xA7r`).join(", "), h.tags.map(w => `\xA7p${w}\xA7r`).join(", ")].removeFalsies().join("; ")}`, h.tags.filter(w => !w.includes(":")).map(w => n[`minecraft:${w}`]).removeFalsies().flat().map(w => w.replace(/^minecraft:/, "")).forEach(w => o.addItem(w)), d[f] = new Set, o.export().forEach(({ translationKey: w, translatedName: x }) => { d[f].add(w), c[w] = x }) }), u[l] = "", Object.entries(d).forEach(([f, h]) => { h.forEach(g => { u[l] += `
${g}=${c[g]}\\n\xA7u${p[f]}\xA7r` }) }) }), { inGameControls: s, controlItemTranslations: u } }
async function Nr(i) { // Função que gera ícone dinamicamente
    // MODIFICADO POR HOLOLAB: Cores ajustadas para o tema azul
    let e = [...await fe(i)], t = e.map(f => [7, 6, 5, 4, 3, 2, 1, 0].map(h => f >> h & 1)).flat(), r = [4, 6][e[1] % 2], a = 200 / r, n = !1, o = new OffscreenCanvas(256, 256), s = o.getContext("2d"); s.lineWidth = 8, s.lineCap = "round";
    let u = (o.width - r * a) / 2, l = (f, h, g, m) => { s.beginPath(), s.arc(f * a + u, h * a + u, a / 2, g, m), s.stroke() }, p = (f, h, g, m) => { s.beginPath(), s.moveTo(f * a + u, h * a + u), s.lineTo((f + g) * a + u, (h + m) * a + u), s.stroke() };
    for (let f = 0; f < r; f++)for (let h = 0; h < r; h++) { let g = de(f, r - 1 - f) * r + h; g *= 4; let m = t[g]; if (n) { if (t[g] && t[g + 1] && t[g + 2] && t[g + 3]) { l(f + .5, h + .5, 0, ne * 2); continue } if (!t[g] && !t[g + 1] && !t[g + 2] && !t[g + 3]) { p(f, h + .5, 1, 0), p(f + .5, h, 0, 1); continue } } m == f >= r / 2 ? (l(f, h, 0, ne / 2), l(f + 1, h + 1, ne, ne * 3 / 2)) : (l(f + 1, h, ne / 2, ne), l(f, h + 1, ne * 3 / 2, ne * 2)) }
    let c = e[0] / 256 * 360; // Mantém a lógica de matiz original
    // Gradiente azul
    let primaryBlueBase = [0, 123, 255]; // R, G, B for #007bff
    let hueShift = (c + 180) % 360; // Muda a matiz baseada no hash, mantendo-o "azulado"
                                // Poderia ser mais sofisticado para garantir que permaneça azul.
                                // Por simplicidade, um tom fixo ou uma variação menor de azul.
    let color1 = `hsl(${hueShift}, 70%, 50%)`; // Azul principal
    let color2 = `hsl(${(hueShift + 20) % 360}, 60%, 60%)`; // Azul um pouco mais claro/diferente
    let bgColor = `hsl(${hueShift}, 40%, 85%)`; // Fundo bem claro, quase branco azulado

    let d = s.createRadialGradient(o.width / 2, o.height / 2, 0, o.width / 2, o.height / 2, r * a / 2 * Math.SQRT2);
    d.addColorStop(0, color1);
    d.addColorStop(1, color2);
    s.globalCompositeOperation = "source-in", s.fillStyle = d, s.fillRect(0, 0, o.width, o.height), s.globalCompositeOperation = "destination-over", s.fillStyle = bgColor, s.fillRect(0, 0, o.width, o.height);
    return await o.convertToBlob()
}
function Br(i, e) { let r = i.tags.filter(a => !a.includes(":")).map(a => e[`minecraft:${a}`]).flat().removeFalsies(); return [...i.names, ...r.map(a => a.replace(/^minecraft:/, ""))] }
function z(i, e = "slot.weapon.mainhand") { let t = i.names.map(o => o.includes(":") ? o : `minecraft:${o}`), r = i.tags.map(o => o.includes(":") ? o : `minecraft:${o}`), a = t.length > 0 ? `q.is_item_name_any('${e}',${t.map(o => `'${o}'`).join(",")})` : void 0, n = r.length > 0 ? `q.equipped_item_any_tag('${e}',${r.map(o => `'${o}'`).join(",")})` : void 0; return [a, n].removeFalsies().join("||") || "false" }
function Le(i, e) { let t = Object.entries(i); return jt(t, e) }
function jt(i, e) { if (i.length > 50) { let r = he(i.length / 2); return `${e}<${i[r][0]}?(${jt(i.slice(0, r), e)}):(${jt(i.slice(r), e)})` } return i.map(([r, a], n) => n == i.length - 1 ? a : `${n > 0 ? "(" : ""}${e}==${r}?${a}:`).join("") + ")".repeat(G(i.length - 2, 0)) }
function Pr(i, e, t) { return Le(i.map(r => `(${Le(r, t)})`), e) }
function xe(i, e = {}) { let t = i.toString(), r = t.slice(t.indexOf("{") + 1, t.lastIndexOf("}")).replaceAll(/\/\/.+/g, "").replaceAll(/(?<!return)\s/g, ""), a = ""; for (let d = 0; d < r.length; d++) { if (r.slice(d, d + 7) == "elseif(") { a += "else{if("; let f = !1, h = 0; d += 6; let g = d; for (; h > 0 || !f; g++)r[g] == "{" ? (h++, f = !0) : r[g] == "}" && h--, h == 0 && f && r.slice(g, g + 5) == "}else" && (f = !1); r = r.slice(0, g) + "}" + r.slice(g); continue } a += r[d] } let n = a.replaceAll('"', "'").replaceAll(/([\w\.]+)(\+|-){2};/g, "$1=$1$21;").replaceAll(/([\w\.]+)--;/g, "$1=$1-1;").replaceAll(/([\w\.\$\[\]]+)(\+|-|\*|\/|\?\?)=([^;]+);/g, "$1=$1$2$3;"), o = (d, f) => d.replaceAll(/\$\[(\w+)(?:\[(\d+)\]|\.(\w+))?(?:(\+|-|\*|\/)(\d+))?\]/g, (h, g, m, v, w, x) => { if (g in f) { let E = f[g]; if (m ??= v, m != null) if (m in E) E = E[m]; else throw new RangeError(`Índice fora dos limites: [${E.join(", ")}][${m}] não existe`); switch (w) { case "+": return +E + +x; case "-": return E - x; case "*": return E * x; case "/": return E / x; default: return E } } else throw new ReferenceError(`Variável "${g}" não foi passada para a função -> conversor Molang!`) }), s = "", u = 0, l = !1, p = !1; for (let d = 0; d < n.length; d++) { let f = n[d]; if (n.slice(d, d + 3) == "if(") { l = !0, u++, p = /^if\([^()]+\?\?/.test(n.slice(d)), p && (s += "("), d += 2; continue } else if (n.slice(d, d + 4) == "else") { s = s.slice(0, -1) + ":", d += 3; continue } else if (/^for\([^)]+\)/.test(n.slice(d))) { let h = o(n.slice(d).match(/^for\([^)]+\)/)[0], e), [, g, m, v] = h.match(/^for\(let(\w+)=(\d+);\w+<(\d+);\w+\+\+\)/), w = n.slice(d).indexOf("{") + d, x = w + 1, E = 1; for (; E > 0;)n[x] == "{" ? E++ : n[x] == "}" && E--, x++; let $ = n.slice(w + 1, x - 1), k = ""; for (let C = +m; C < v; C++)k += o($, { ...e, [g]: C }); n = n.slice(0, d) + k + n.slice(x), d--; continue } else if (f == "(") u++; else if (f == ")") { if (u--, u == 0 && l) { l = !1, p && (s += ")"), s += "?"; continue } } else if (f == "}") { s += "};"; continue } s += f } return o(s, e) } // TRADUÇÕES HOLOLAB (em mensagens de erro)
function Mr(i) { return JSON.stringify(i, (t, r) => (typeof r == "number" && (r = Number(r.toFixed(4))), r)) }
var Ye = class { supabase; constructor(e, t) { this.supabase = import("@supabase/supabase-js").then(r => r.createClient(e, t)) } async recordPackCreation(e) { this.supabase instanceof Promise && (this.supabase = await this.supabase), console.info("Hashing arquivos de estrutura..."); let r = (await Promise.all(e.map(async o => (await fe(o)).toHexadecimalString()))).map(o => o.slice(0, 8)), a = (await fe(lt(e))).toHexadecimalString().slice(0, 8); console.debug(`Hashing de arquivos de estrutura finalizado! Juntos: ${a}, individualmente:`, r); let n = await this.supabase.rpc("record_structure_usage_v2", { file_hashes: r, combined_file_hash: a }); if (n.status == 200) console.info(`Hash da estrutura registrado com sucesso no banco de dados!\nEsta é a ${ya(n.data)} vez que esta estrutura foi usada.`); else throw new Error(`Erro SupabaseLogger ${n.error.code}: ${n.error.message}`) } }; // TRADUÇÕES HOLOLAB
var Ma = new Ge().then(async i => { let t = (await i.fetch("metadata/vanilladata_modules/mojang-items.json").then(a => a.json())).data_items.map(a => a.name.replace(/^minecraft:/, "")), r = document.createElement("datalist"); return r.id = "itemNamesDatalist", r.append(...t.map(a => new Option(a))), r }), ja = Vt().then(async i => { let e = await i.fetch("item_tags.json").then(a => a.json()), t = Object.keys(e).map(a => a.replace(/^minecraft:/, "")), r = document.createElement("datalist"); return r.id = "itemTagsDatalist", r.append(...t.map(a => new Option(a))), r }), Je = class extends HTMLElement { static formAssociated = !0; static observedAttributes = ["value-items", "value-tags"]; internals;#e;#i;#t;#r; constructor(e) { super(), this.#t = e, this.attachShadow({ mode: "open" }), this.internals = this.attachInternals(), this.#e = !1, this.#i = [] } connectedCallback() { if (this.#e) return; this.#e = !0, this.tabIndex = 0, this.shadowRoot.innerHTML = '<style>:host{padding-left:15px;font-size:.8rem;display:block}#criteriaInputs:empty:before{content:attr(data-empty-text)}button{background:color-mix(in srgb,var(--accent-col)50%,white);cursor:pointer;font-family:inherit;line-height:inherit}input,button{box-sizing:border-box;border-style:solid;border-color:var(--accent-col);outline-color:var(--accent-col);accent-color:var(--accent-col)}input{font-family:monospace}input.itemNameInput,#addItemButton{--accent-col:#01808c}input.itemTagInput,#addTagButton{--accent-col:#e6be1a}input:invalid:not(:-ms-placeholder-shown){--accent-col:#e24436}input:invalid:not(:placeholder-shown){--accent-col:#e24436}</style><label data-translate="item_criteria_input.matching">Matching:</label> <label id="criteriaInputs" data-empty-text="Nothing" data-translate-data-empty-text="item_criteria_input.nothing"></label> <button id="addItemButton">+ <span data-translate="item_criteria_input.item_name">Item name</span></button> <button id="addTagButton">+ <span data-translate="item_criteria_input.item_tag">Item tag</span></button>', this.#r = this.shadowRoot.selectEl("#criteriaInputs"), this.shadowRoot.selectEl("#addItemButton").onEvent("click", () => { this.#o("item") }), this.shadowRoot.selectEl("#addTagButton").onEvent("click", () => { this.#o("tag") }); let e; for (; e = this.#i.shift();)e(); this.#r.onEventAndNow("input", () => this.#a()), this.onEvent("focus", async t => { t.composedPath()[0] instanceof this.constructor && (this.shadowRoot.selectEl("input:invalid") ?? this.shadowRoot.selectEl("input:last-child") ?? this.shadowRoot.selectEl("#addItemButton")).focus(), this.shadowRoot.append(await Ma, await ja) }), this.onEvent("blur", async () => { [...this.#r.selectEls("input")].filter(t => t.value.trim() == "").map(t => t.remove()).length && (this.#a(), this.#l()), this.shadowRoot.removeChild(await Ma), this.shadowRoot.removeChild(await ja) }) } attributeChangedCallback(...e) { this.#e ? this.#n(...e) : this.#i.push(() => { this.#n(...e) }) } formResetCallback() { this.value = this.getAttribute("default") ?? "{}" } get form() { return this.internals.form } get name() { return this.getAttribute("name") } get type() { return this.localName } get value() { let e = [...this.#r.selectEls(".itemNameInput")].map(r => r.value.trim()), t = [...this.#r.selectEls(".itemTagInput")].map(r => r.value.trim()); return JSON.stringify(J(e, t)) } set value(e) { this.#r.innerHTML = ""; let t = JSON.parse(e.replaceAll("'", '"')); t.names?.forEach(r => { this.#o("item", !1, r) }), t.tags?.forEach(r => { this.#o("tag", !1, r) }) } #a() { this.internals.setFormValue(this.value); let e = [...this.#r.selectEls("input")]; e.length == 0 ? this.internals.setValidity({ tooShort: !0 }, this.#t?.("item_criteria_input.error.empty") ?? "Por favor, insira critérios de item") : e.some(t => !t.validity.valid) ? this.internals.setValidity({ patternMismatch: !0 }, this.#t?.("item_criteria_input.error.invalid") ?? "Nome de item/tag inválido") : this.internals.setValidity({}) } #n(e, t, r) { let a = JSON.parse(this.value); switch (r = r.split(","), e) { case "value-items": a.names = r; break; case "value-tags": a.tags = r; break } this.value = JSON.stringify(a) } #o(e, t = !0, r) { let a = { item: 'placeholder="Item name" list="itemNamesDatalist" class="itemNameInput" data-translate-placeholder="item_criteria_input.item_name"', tag: 'placeholder="Tag name" list="itemTagsDatalist" class="itemTagInput" data-translate-placeholder="item_criteria_input.item_tag"' }; this.#r.selectEl("input:last-child:placeholder-shown")?.remove(); let n = [...this.#r.childNodes].at(-1); if (n && !(n instanceof HTMLSpanElement)) { let s = document.createElement("span"); s.dataset.translate = "item_criteria_input.or", s.innerText = " ou ", this.#r.appendChild(s) } let o = Oa(`<input type="text" required pattern="^\\s*(\\w+:)?\\w+\\s*$" spellcheck="false" autocapitalize="off" ${a[e]}/>`); o.onEvent("keydown", this.#s), r != null && (o.value = r), this.#r.appendChild(o), t && o.focus(), this.#a() } #s = e => { e.target.value != "" && (e.key == "Tab" && !e.shiftKey && e.target == this.#r.selectEl("input:last-child") || e.key == "Enter" || e.key == ",") ? (e.preventDefault(), this.#o(e.target.classList.contains("itemNameInput") ? "item" : "tag"), this.#a()) : e.key == "Backspace" && e.target.value == "" && (e.preventDefault(), e.target.remove(), this.#l(), this.focus(), this.#a()) }; #l() { [...this.#r.children].forEach(e => { e instanceof HTMLSpanElement && (e.previousSibling instanceof HTMLSpanElement || e.nextSibling instanceof HTMLSpanElement || !e.previousSibling || !e.nextSibling) && e.remove() }) } }; // TRADUÇÕES HOLOLAB (mensagens de erro)
var Xe = class i extends HTMLElement { static observedAttributes = ["file-count-text", "empty-text", "remove-all-text", "hide-file-extensions"]; static #e = wa(["MOVE_DOWN", "MOVE_UP"]); static #i = 400; fileInput;#t;#r;#a;#n;#o; constructor() { super(), this.attachShadow({ mode: "open" }), this.#o = new WeakMap } connectedCallback() { if (this.childElementCount != 1 || !(this.children[0] instanceof HTMLInputElement) || this.children[0].type != "file") throw new Error("Elementos FileInputTable precisam de exatamente 1 filho: um input de arquivo!"); this.fileInput = this.children[0], this.#s(), this.fileInput.onEvent("input", () => this.#l()), this.#l() } attributeChangedCallback(e, t, r) { let a = this.shadowRoot.selectEl(`[data-text-attribute="${e}"]`); if (a) { a.textContent = r; return } if (this.#t) switch (e) { case "file-count-text": case "empty-text": { this.#d(); break } case "hide-file-extensions": { this.#l(); break } } } #s() { this.shadowRoot.innerHTML = '<style>:host{width:100%;display:block}#main{border:4px ridge #adadad;width:70%;margin:auto}#main>*{width:100%}@supports (-webkit-text-zoom:normal){#main{border-color:#626262}}#fileCountHeadingWrapper{box-sizing:border-box;background:rgba(0,0,0,.17);height:22px;margin:0;padding:1px 1px 1px 3px}#fileCountHeading{font-size:1em;font-weight:700}#removeAllFilesButton{float:right;box-sizing:border-box;height:100%;font-family:inherit;line-height:inherit;cursor:pointer;background:rgba(0,0,0,.157);border:1px solid #000;border-radius:7px;padding:0 4px;font-size:smaller;transition:transform .15s}#removeAllFilesButton .material-symbols{vertical-align:top;width:1ch;font-size:120%;display:inline-block}#removeAllFilesButton:hover{transform:scale(1.05)}#removeAllFilesButton:active{transform:scale(1.02)}button{color:inherit}table{border-collapse:collapse;table-layout:fixed}tr:first-child .moveUpButton{visibility:hidden}tr:last-child .moveDownButton{visibility:hidden}tr:only-child .dragMoveCell{opacity:0;cursor:initial}tr:nth-child(odd){background:rgba(0,0,0,.067)}tr.beingDragged{background:rgba(0,0,0,.157);transition:background .1s;position:relative}tr:not(:only-child):not(.beingDeleted) .dragMoveCell{cursor:grab}tr:not(:only-child):not(.beingDeleted) .dragMoveCell:active{cursor:grabbing}td:first-child{text-overflow:ellipsis;padding:0 3px;overflow:hidden}td:last-child{-webkit-user-select:none;-ms-user-select:none;user-select:none;width:5.06rem;padding:0}td div{height:24px;display:flex}td div *{text-align:center;width:1.265rem;height:24px;font-size:115%;transition:font-size .1s}td button{cursor:pointer;background:0 0;border:none;padding:0}td button:not(.dragMoveCell):active{font-size:80%}.material-symbols{font-family:Material Symbols;line-height:1}</style><div id="main"><p id="fileCountHeadingWrapper"><span id="fileCountHeading"></span><button id="removeAllFilesButton"><span data-text-attribute="remove-all-text">Remove all</span> <span class="material-symbols">delete_sweep</span></button></p><table></table></div>', this.#r = this.shadowRoot.selectEl("#fileCountHeading"); let e = this.shadowRoot.selectEl("#removeAllFilesButton"); this.#t = this.shadowRoot.selectEl("table"), this.#d(), this.#h(), new MutationObserver(() => { this.#d(), this.#h() }).observe(this.#t, { childList: !0, subtree: !0 }), e.onEvent("click", async () => { for (let r of this.#t.selectEls(".deleteButton"))r.click(), await Ae(i.#i * .15) }), this.#t.addEventListener("click", r => { if (!(r.target instanceof HTMLButtonElement)) return; let a = r.target.closest("tr"); if (r.target.classList.contains("moveUpButton")) this.#c(a.previousElementSibling, i.#e.MOVE_DOWN, !1), a.previousElementSibling.before(a), this.#c(a, i.#e.MOVE_UP); else if (r.target.classList.contains("moveDownButton")) this.#c(a.nextElementSibling, i.#e.MOVE_UP, !1), a.nextElementSibling.after(a), this.#c(a, i.#e.MOVE_DOWN); else if (r.target.classList.contains("deleteButton")) this.#f(a); else return; this.#p() }), this.#t.onEvents(["dragstart", "touchstart"], r => { if (r.target.classList.contains("dragMoveCell") && getComputedStyle(r.target).opacity != "0") { let a = r.target.closest("tr"); if (a.classList.contains("beingDeleted")) { r.preventDefault(); return } this.#a = a, this.#a.classList.add("beingDragged"), r.type == "dragstart" ? (r.dataTransfer.effectAllowed = "move", r.dataTransfer.dropEffect = "move", r.dataTransfer.setDragImage(this.#a.cells[0], 0, 0)) : this.#n = r.changedTouches[0].clientY } }, { passive: !1 }), this.#t.onEvents(["dragover", "touchmove"], r => { if (!this.#a) return; r.preventDefault(); let a; if (r.type == "dragover") a = r.target.closest("tr"); else { let n = r.changedTouches[0]; Nt(n, this.#t) && (a = Array.from(this.#t.rows).find(o => o != this.#a && Nt(n, o))) } if (a && a != this.#a && !a.getAnimations().length) { let n = this.#a.offsetTop; if (this.#a.rowIndex < a.rowIndex) { for (let s = this.#a.rowIndex + 1; s <= a.rowIndex; s++)this.#c(this.#t.rows[s], i.#e.MOVE_UP, !1); a.after(this.#a), this.#c(this.#a, r.type == "dragover" ? i.#e.MOVE_DOWN : void 0) } else { for (let s = a.rowIndex; s < this.#a.rowIndex; s++)this.#c(this.#t.rows[s], i.#e.MOVE_DOWN, !1); a.before(this.#a), this.#c(this.#a, r.type == "dragover" ? i.#e.MOVE_UP : void 0) } let o = this.#a.offsetTop - n; this.#n += o, this.#p() } if (r.type == "touchmove") { let n = parseFloat(this.#a.style.top) || 0, o = this.#t.getBoundingClientRect(), s = this.#a.getBoundingClientRect(), u = de(o.top - (s.top - n), 0), l = G(o.bottom - (s.bottom - n), 0), p = ua(r.changedTouches[0].clientY - this.#n, u, l); this.#a.style.top = `${p}px` } }, { passive: !1 }), this.#t.onEvents(["dragend", "touchend", "touchcancel"], () => { this.#a && (this.#a.classList.remove("beingDragged"), this.#a.style.left = "", this.#a.style.top = "", this.#a = null) }) } #l() { let e = this.#t.rows.length > 0, t = e && new Set(Array.from(this.#t.rows).map(r => this.#o.get(r))); this.#t.textContent = "", Array.from(this.fileInput.files).forEach(r => { let a = this.#t.insertRow(); this.#o.set(a, r); let n = a.insertCell(); n.textContent = this.hasAttribute("hide-file-extensions") && r.name.lastIndexOf(".") != 0 ? Ta(r.name) : r.name, this.#u(a), e && !t.has(r) && this.#c(a) }) } #d() { if (this.fileInput.files.length) { let e = this.getAttribute("file-count-text") ?? "{COUNT} arquivo(s) selecionado(s)", t = this.fileInput.files.length > 1 ? e.replaceAll(/\[|\]/g, "") : e.replaceAll(/\[.+\]/g, ""); this.#r.textContent = t.replace("{COUNT}", this.fileInput.files.length) } else this.#r.textContent = this.getAttribute("empty-text") ?? "Nenhum arquivo selecionado" } #h() { this.fileInput.files.length ? this.setAttribute("has-files", "") : this.removeAttribute("has-files") } #u(e) { e.insertAdjacentHTML("beforeend", '<td><div><button class="moveUpButton material-symbols">arrow_upward</button> <button class="moveDownButton material-symbols">arrow_downward</button> <button class="deleteButton material-symbols">delete</button> <button draggable="true" class="dragMoveCell material-symbols">drag_indicator</button></div></td>') } #p() { let e = Array.from(this.#t.rows).filter(r => !r.classList.contains("beingDeleted")).map(r => this.#o.get(r)), t = new DataTransfer; e.forEach(r => t.items.add(r)), this.fileInput.files = t.files, this.#d() } #c(e, t, r = !0) { let a = {}; if (t && (a = { transform: `translateY(${e.getBoundingClientRect().height * (t == i.#e.MOVE_DOWN ? -1 : 1)}px)`, composite: "add" }), r) { let n = { transform: "scale(1.08)", boxShadow: "0 0 5px #0008" }; for (let o = 0; o < 2; o++)e.animate([o == 0 ? a : {}, { ...n, offset: .3 }, { ...n, offset: .7 }, {}], { duration: i.#i, easing: "ease" }) } else e.animate([a, {}], { duration: i.#i * .3, easing: "ease" }) } async #f(e) { if (e.classList.contains("beingDeleted")) return; e.classList.add("beingDeleted"), await e.animate({ opacity: [1, 0] }, { duration: i.#i, easing: "cubic-bezier(0.165, 0.84, 0.44, 1)" }).finished; for (let a = e.rowIndex + 1; a < this.#t.rows.length; a++)this.#c(this.#t.rows[a], i.#e.MOVE_UP, !1); let r = e.getBoundingClientRect().height; this.#t.animate({ marginBottom: [r + "px", "0"] }, { duration: i.#i * .3, easing: "ease", composite: "add" }), e.remove() } }; // TRADUÇÕES HOLOLAB (em mensagens de erro e texto padrão)
var Ke = class extends HTMLElement { #e; node; allLogs = [];#i;#t;#r;#a; constructor() { super(), this.attachShadow({ mode: "open" }) } connectedCallback() { this.shadowRoot.innerHTML = '<style>#root{color:#fff;text-align:left;max-height:300px;margin:15px;font-family:monospace;font-size:14px;display:block;position:relative;overflow:auto}.logHeader{background:#556;height:20px;padding:2px 2px 2px 12px;position:-webkit-sticky;position:sticky;top:0}.logHeader *{margin-left:30px}#downloadLogsButton{background:inherit;color:#fff;float:right;box-sizing:border-box;cursor:pointer;font:inherit;border:1px solid #ccc;border-radius:7px}#downloadLogsButton:hover{background:#4d4d5d}#downloadLogsButton:active{background:#445}.log{overflow-wrap:break-word;background:#223;margin:0;padding:2px 12px}.log:nth-child(2n){background:#334}.warning>.logText:before{content:"\u26A0\uFE0F"}.error>.logText:before{content:"\u{1F6A8}"}.info>.logText:before{content:"\u2139\uFE0F"}.timestamp{color:#ccc;background:#556;margin-right:5px;padding:0 2px}</style><div id="root"><div class="logHeader">Logs<span id="errorCount">\u{1F6A8}0</span><span id="warningCount">\u26A0\uFE0F0</span><button type="button" id="downloadLogsButton">Baixar logs</button></div></div>', this.node = this.shadowRoot.selectEl("#root"), this.node.selectEl("#downloadLogsButton").onEvent("click", () => { Fe(new Blob([JSON.stringify(this.allLogs)]), "hololab_logs.json") }), this.#a = this.node.selectEl("#warningCount"), this.#r = this.node.selectEl("#errorCount"), this.#i = 0, this.#t = 0, this.#e = performance.now() } warn(e) { this.#n(e, "warning") && (this.#a.innerText = `\u26A0\uFE0F${++this.#t}`) } error(e) { this.#n(e, "error") && (this.#r.innerText = `\u{1F6A8}${++this.#i}`) } info(e) { this.#n(e, "info") } debug(e) { this.#n(e, "debug") } setOriginTime(e) { this.#e = e } #n(e, t) { let r = pe().slice(2); if (this.allLogs.push({ text: e, level: t, stackTrace: r, time: performance.now() - this.#e }), t == "debug") return; let a = location.href.slice(0, location.href.lastIndexOf("/")); if (r.some(l => /https?:\/\//.test(l) && !l.includes(a) && !l.includes("<anonymous>"))) return; let n = document.createElement("p"); n.classList.add("log"), t && n.classList.add(t); let o = this.#o(); n.appendChild(o); let s = document.createElement("span"); s.classList.add("logText"), s.innerText = e, n.appendChild(s); let u = je(this.node.scrollTop + this.node.getBoundingClientRect().height) >= this.node.scrollHeight; return this.node.appendChild(n), u && (this.node.scrollTop = this.node.scrollHeight), !0 } #o() { let e = document.createElement("span"); e.classList.add("timestamp"); let t = new Date(performance.now() - this.#e), r = `${t.getUTCMinutes().toString().padStart(2, "0")}:${t.getUTCSeconds().toString().padStart(2, "0")}.${t.getUTCMilliseconds().toString().padStart(3, "0")}`; return t.getUTCHours() > 0 && (r = `${t.getUTCHours().toString().padStart(2, "0")}:${r}`), e.innerText = r, e } patchConsoleMethods() { [console._warn, console._error, console._info, console._debug] = [console.warn, console.error, console.info, console.debug], console.warn = (...e) => (this.warn(e.join(" ")), console._warn.apply(console, [pe()[1].match(/\/([^\/]+\.[^\.]+:\d+:\d+)/)[1] + `
`, ...e])), console.error = (...e) => (this.error(e.join(" ")), console._error.apply(console, [pe()[1].match(/\/([^\/]+\.[^\.]+:\d+:\d+)/)[1] + `
`, ...e])), console.info = (...e) => (this.info(e.join(" ")), console._info.apply(console, [pe()[1].match(/\/([^\/]+\.[^\.]+:\d+:\d+)/)[1] + `
`, ...e])), console.debug = (...e) => (this.debug(e.join(" ")), console._debug.apply(console, [pe()[1].match(/\/([^\/]+\.[^\.]+:\d+:\d+)/)[1] + `
`, ...e])) } }; // MODIFICADO POR HOLOLAB: Nome do arquivo de log
var Da = !0, Va = !1;
// MODIFICADO POR HOLOLAB: Remova ou substitua estas chaves do Supabase se não for usar telemetria
// Ou, se for usar, substitua pelas SUAS PRÓPRIAS chaves.
var Dr = "https://gnzyfffwvulwxbczqpgl.supabase.co", Ur = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImduenlmZmZ3dnVsd3hiY3pxcGdsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjMwMjE3NzgsImV4cCI6MjAzODU5Nzc3OH0.AWMhFcP3PiMD3dMC_SeIVuPx128KVpgfkZ5qBStDuVw";
window.OffscreenCanvas; var ut, H, Gt, ke, Se, Te, Oe, $e, Wt, Yt, Z, Ga, Ua, mt, pt;
document.onEvent("DOMContentLoaded", () => {
    document.body.appendChild = B("main").appendChild.bind(B("main")), Lt('input[type="file"][accept]:not([multiple])').forEach(h => { h.onEventAndNow("input", g => { zr(h) || g?.stopImmediatePropagation() }) }), H = B("#generatePackForm"), ut = B("#dropFileNotice"), ke = B("#structureFilesInput"); let i = B("#notStructureFileError"); Se = B("#worldFileInput"); let e = B("#worldExtractionMessage"), t = B("#worldExtractionSuccess"), r = B("#worldExtractionError"), a = B("#worldExtractionWorldError"); Te = B("#oldPackInput"); let n = B("#oldPackExtractionMessage"), o = B("#oldPackExtractionSuccess"), s = B("#oldPackExtractionError"); Oe = B("#structureFilesList"), $e = H.elements.namedItem("packName"), $e.onEvent("invalid", () => { $e.setCustomValidity(Xt("metadata.pack_name.error")) }), $e.onEvent("input", () => { $e.setCustomValidity("") }), ke.onEvent("input", () => { if (!ke.files.length) return; let h = Array.from(ke.files), g = h.filter(m => m.name.endsWith(".mcstructure")); h.length == g.length ? (i.classList.add("hidden"), ke.setCustomValidity("")) : (i.classList.remove("hidden"), ke.setCustomValidity(i.textContent)), De(Oe, g) }), Se.onEvent("input", async () => { e.classList.add("hidden"), t.classList.add("hidden"), r.classList.add("hidden"), a.classList.add("hidden"), Te.setCustomValidity(""); let h = Se.files[0]; if (!h) return; B("#extractFromWorldTab").checked = !0, e.classList.remove("hidden"), e.scrollIntoView({ block: "center" }); let g; try { g = await jr(h) } catch (m) { e.classList.add("hidden"), a.dataset.translationSubError = m, a.classList.remove("hidden"), Se.setCustomValidity(a.textContent); return } e.classList.add("hidden"), g.size ? (De(Oe, Array.from(g.values())), t.dataset.translationSubCount = g.size, t.classList.remove("hidden")) : (r.classList.remove("hidden"), Se.setCustomValidity(r.textContent)) }), Te.onEvent("input", async () => { n.classList.add("hidden"), o.classList.add("hidden"), s.classList.add("hidden"), Te.setCustomValidity(""); let h = Te.files[0]; if (!h) return; B("#updatePackTab").checked = !0, n.classList.remove("hidden"), n.scrollIntoView({ block: "center" }); let g = await Ba(h); n.classList.add("hidden"), g.length ? (De(Oe, g), o.classList.remove("hidden")) : (s.classList.remove("hidden"), Te.setCustomValidity(s.textContent)) }), Oe.onEventAndNow("input", Fr), Wt = B("#completedPacksCont"), mt = B("#texturePreviewImageCont"), Ga = new ge, location.search == "?loadFile" && window.launchQueue?.setConsumer(async h => { let g = await Promise.all(h.files.map(m => m.getFile())); Fa(g) }); let u = 0; document.documentElement.onEvent("dragenter", () => { u++ }), document.documentElement.onEvent("dragover", h => { h.dataTransfer?.types?.includes("Files") && (h.preventDefault(), ut.classList.remove("hidden")) }), document.documentElement.onEvent("dragleave", () => { u--, u == 0 && ut.classList.add("hidden") }), document.documentElement.onEvent("drop", async h => { h.preventDefault(), u = 0, ut.classList.add("hidden"); let g = [...h.dataTransfer.files]; Fa(g) }), customElements.define("item-criteria-input", class extends Je { constructor() { super(Xt) } }), customElements.define("file-input-table", Xe), customElements.define("simple-logger", Ke), Va || (Yt = B("#log"), Yt.patchConsoleMethods()), H.onEvent("submit", async h => { h.preventDefault(); let g = new FormData(H), m = [], v = H.elements.namedItem("localResourcePack").files; v.length && m.push(await new Ve(v)), Hr(g.getAll("structureFiles"), m) }), H.onEvent("input", h => { h.target.closest("fieldset")?.classList?.contains("textureSettings") && h.target.hasAttribute("name") && za() }), za(), Gt = H.elements.namedItem("submit"); let l = H.elements.namedItem("opacityMode"); l.onEventAndNow("change", () => { H.elements.namedItem("opacity").parentElement.classList.toggle("hidden", l.value == "multiple") }); let p = H.elements.namedItem("description"), c = B("#descriptionLinksCont"); p.onEventAndNow("input", () => { let h = zt(p.value); c.textContent = "", h.forEach(([g, m], v) => { v && c.appendChild(document.createElement("br")), c.insertAdjacentHTML("beforeend", '<span data-translate="metadata.description.link_found">Link found:</span>'), c.insertAdjacentText("beforeend", " " + m) }) }); let d = B("#playerControlsInputCont"); Object.entries(ht).map(([h, g]) => { let m = document.createElement("label"), v = Dt[h]; m.innerHTML = `<span data-translate="${v}">...</span>:`; let w = document.createElement("item-criteria-input"); w.setAttribute("name", `control.${h}`), g.names.length > 0 && w.setAttribute("value-items", g.names.join(",")), g.tags.length > 0 && w.setAttribute("value-tags", g.tags.join(",")), m.appendChild(w), d.appendChild(m), w.setAttribute("default", w.value) }); let f = B("#clearResourcePackCacheButton"); f.onEvent("click", async () => { caches.clear(), Ha(f, f.dataset.resetTranslation) }), Lt(".resetButton").forEach(h => { h.onEvent("click", () => { let g = h.parentElement, [m, v] = _a(Array.from(H.elements), x => x.localName != "fieldset" && x.localName != "button" && (!g.contains(x) || !x.hasAttribute("name"))), w = v.map(x => { switch (x.type) { case "file": { let E = new DataTransfer; return [...x.files].forEach($ => E.items.add($)), E.files } case "checkbox": return x.checked; default: return x.value } }); H.reset(), v.forEach((x, E) => { switch (x.type) { case "file": x.files = w[E]; break; case "checkbox": x.checked = w[E]; break; default: x.value = w[E] } }), m.forEach(x => { Rt(x) }), Ha(h, h.dataset.resetTranslation) }) }), Z = B("#languageSelector"), fetch("translations/languages.json").then(h => h.jsonc()).then(h => { h = Object.fromEntries(Object.entries(h).sort((E, $) => E[1] > $[1])); let g = Object.keys(h); if (g.length == 1) { B("#languageSelectorCont").remove(); return } let m = navigator.languages.find(E => { let $ = E.split("-")[0]; return g.find(k => k == E) ?? g.find(k => k == $) ?? g.find(k => k.split(/-|_/)[0] == $) }) ?? "en_US"; Z.textContent = ""; for (let E in h) Z.appendChild(new Option(h[E], E, !1, E == m)); Z.onEventAndNow("change", () => { Jt(Z.value) }); let v = !1, w = new MutationObserver(E => { if (v) { console.log("Mutações observadas ao retraduzir:", E); return } E.find(k => k.type == "childList" && [...k.addedNodes].some(C => C instanceof Element && ([...C.attributes].some(M => M.name.startsWith("data-translate") || M.name.startsWith("data-translation-sub-")) || C.getAllChildren().some(M => [...M.attributes].some(D => D.name.startsWith("data-translate") || D.name.startsWith("data-translation-sub-"))))) || k.type == "attributes" && (k.attributeName.startsWith("data-translate") || k.attributeName.startsWith("data-translation-sub-")) && k.target.getAttribute(k.attributeName) != k.oldValue) && (v = !0, Jt(Z.value), v = !1) }), x = { childList: !0, subtree: !0, attributes: !0, attributeOldValue: !0 }; w.observe(document.body, x), document.body.getAllChildren().filter(E => E.shadowRoot).forEach(E => { w.observe(E.shadowRoot, x) }) })
});
window.onEvent("load", () => { location.search == "?generateEnglishTranslations" && Jt("en_US", !0) });
async function Fa(i) { let { mcstructure: e = [], mcworld: t = [], zip: r = [], mcpack: a = [] } = Ea(i), n = [...t, ...r]; De(Oe, e), ot(Se, n.slice(0, 1)), ot(Te, a.slice(0, 1)) }
function Fr() { $e.setAttribute("placeholder", Ft([...Oe.files])) }
async function za() { // Função de preview de textura
    // MODIFICADO POR HOLOLAB: Cores e imagem de preview
    // Se você quiser uma imagem de preview totalmente customizada, altere a linha abaixo:
    // pt??=await fetch('assets/seu_preview_de_textura.png').then(s => s.ok ? s.toImage() : new Image());
    pt ??= await Ga.then(s => s.fetchResource(`textures/blocks/${ma(["crafting_table_front", "diamond_ore", "blast_furnace_front_off", "brick", "cherry_planks", "chiseled_copper", "cobblestone", "wool_colored_white", "stonebrick", "stone_granite_smooth"])}.png`)).then(s => s.toImage());
    let i = new OffscreenCanvas(pt.width, pt.height); i.getContext("2d").drawImage(pt, 0, 0);
    let t = +H.elements.namedItem("textureOutlineWidth").value,
        // Usa as cores do formulário, que por sua vez podem ser alteradas para azuis se desejado
        textureOutlineColor = H.elements.namedItem("textureOutlineColor").value, // Deveria ser azul pelas vars CSS
        textureOutlineOpacity = H.elements.namedItem("textureOutlineOpacity").value / 100,
        tintColor = H.elements.namedItem("tintColor").value, // Deveria ser azul pelas vars CSS
        tintOpacity = H.elements.namedItem("tintOpacity").value / 100;

    let r = t > 0 ? ye.addTextureOutlines(i, [{ x: 0, y: 0, w: i.width, h: i.height }], Ht({ TEXTURE_OUTLINE_COLOR: textureOutlineColor, TEXTURE_OUTLINE_OPACITY: textureOutlineOpacity, TEXTURE_OUTLINE_WIDTH: t })) : i,
        a = await r.convertToBlob().then(s => s.toImage()),
        n = r.getContext("2d");
    n.fillStyle = tintColor, n.globalAlpha = tintOpacity, n.fillRect(0, 0, r.width, r.height);
    let o = await r.convertToBlob().then(s => s.toImage());
    mt.textContent = "", mt.appendChild(a), mt.appendChild(o)
}
async function Jt(i, e = !1) { let t = document.documentElement.getAllChildren().filter(a => [...a.attributes].some(n => n.name.startsWith("data-translate"))); await st(i); let r = e ? await fetch(`translations/${i}.json`).then(a => a.jsonc()) : {}; await Promise.all(t.map(async a => { if ("translate" in a.dataset) { let n = a.dataset.translate; if (e) r[n] = a.innerHTML.replaceAll("<code>", "`").replaceAll("</code>", "`").replaceAll(/<a href="([^"]+)"[^>]*>([^<]+)<\/a>/g, "[$2]($1)"); else { let o = oe(n, i); if (o != null) a.innerHTML = ft(a, o); else if (console.warn(`Não foi possível encontrar tradução para ${n} no idioma ${i}!`), a.innerHTML == "") { let s = oe(n, "en_US"); s ? a.innerHTML = ft(a, s) : a.innerHTML = n } } } [...a.attributes].filter(n => n.name.startsWith("data-translate-")).forEach(async n => { let o = n.name.replace(/^data-translate-/, ""), s = n.value; if (e) r[s] = a.getAttribute(o); else { let u = oe(s, i); if (u != null) a.setAttribute(o, ft(a, u)); else if (console.warn(`Não foi possível encontrar tradução para ${s} no idioma ${i}!`), !a.hasAttribute(o)) { let l = oe(s, "en_US"); l ? a.setAttribute(o, ft(a, l)) : a.setAttribute(o, s) } } }) })), e && (r = Object.fromEntries(Object.entries(r).sort((a, n) => a[0] > n[0])), Fe(new File([JSON.stringify(r, null, "	")], `${i}.json`))) } // TRADUÇÕES HOLOLAB
function ft(i, e) { let t = "data-translation-sub-"; return Array.from(i.attributes).forEach(({ name: r, value: a }) => { if (r.startsWith(t)) { let n = r.slice(t.length).toUpperCase().replaceAll("-", "_"); e = e.replaceAll(`{${n}}`, a), parseInt(a) == a && (e = a > 1 ? e.replace(/\[|\]/g, "") : e.replaceAll(/\[.+\]/g, "")) } }), e }
function Xt(i) {
    // TRADUÇÃO HOLOLAB (mensagens de erro/aviso)
    if (!Z) return; let e = oe(i, Z.value);
    return e || (e = oe(i, "en_US"), e ? console.warn(`Não foi possível encontrar tradução para ${i} no idioma ${Z.value}! Usando Inglês.`) : (console.warn(`Não foi possível encontrar tradução para ${i} no idioma ${Z.value} ou Inglês!`), e = i)), e
}
async function Ha(i, e, t = 2e3) { let r = i.dataset.translate; i.dataset.translate = e, i.setAttribute("disabled", ""), await Ae(t), i.dataset.translate = r, i.removeAttribute("disabled") }
function zr(i) {
    // TRADUÇÃO HOLOLAB (mensagem de erro)
    let e = i.accept.split(","), t = Array.from(i.files).every(r => e.some(a => r.name.endsWith(a)));
    return t ? i.setCustomValidity("") : Z ? i.setCustomValidity(Xt("upload.error.wrong_file_type").replace("{FILE_TYPE}", $t(e, Z.value))) : i.setCustomValidity(`Por favor, envie apenas arquivos ${$t(e)}.`), t
}
async function Hr(i, e) {
    Gt.disabled = !0, Da && console.debug("User agent:", navigator.userAgent);
    let t = new FormData(H), r = t.get("author").split(",").map(p => p.trim()).removeFalsies(),
        // MODIFICADO POR HOLOLAB: Cores padrão para azuis, se não sobrescritas pelo formulário
        a = {
            IGNORED_BLOCKS: t.get("ignoredBlocks").split(/\W/).removeFalsies(), SCALE: t.get("scale") / 100, OPACITY: t.get("opacity") / 100, MULTIPLE_OPACITIES: t.get("opacityMode") == "multiple",
            TINT_COLOR: t.get("tintColor") || "#007bff", // Azul se não definido
            TINT_OPACITY: (t.get("tintOpacity") || 20) / 100,
            MINI_SCALE: +t.get("miniSize"),
            TEXTURE_OUTLINE_WIDTH: +t.get("textureOutlineWidth"),
            TEXTURE_OUTLINE_COLOR: t.get("textureOutlineColor") || "#0056b3", // Azul escuro se não definido
            TEXTURE_OUTLINE_OPACITY: (t.get("textureOutlineOpacity") || 65) / 100,
            SPAWN_ANIMATION_ENABLED: !!t.get("spawnAnimationEnabled"), PLAYER_CONTROLS_ENABLED: !!t.get("playerControlsEnabled"), MATERIAL_LIST_ENABLED: !!t.get("materialListEnabled"), RETEXTURE_CONTROL_ITEMS: !!t.get("retextureControlItems"), RENAME_CONTROL_ITEMS: !!t.get("renameControlItems"), CONTROLS: Object.fromEntries([...t].filter(([p]) => p.startsWith("control.")).map(([p, c]) => [p.replace(/^control./, ""), JSON.parse(c)])), INITIAL_OFFSET: [+t.get("initialOffsetX"), +t.get("initialOffsetY"), +t.get("initialOffsetZ")], BACKUP_SLOT_COUNT: +t.get("backupSlotCount"), PACK_NAME: t.get("packName") || void 0,
            // PACK_ICON_BLOB não é mais lido aqui, pois o ícone é fixo pela URL
            AUTHORS: r, DESCRIPTION: t.get("description") || void 0, COMPRESSION_LEVEL: +t.get("compressionLevel")
        },
        n = document.createElement("div"); n.classList.add("previewCont"), Wt.prepend(n);
    let o = document.createElement("button"); o.classList.add("packInfoButton"), o.dataset.translate = "progress.generating", Wt.prepend(o);
    let s = await new ge(e), u; Yt?.setOriginTime(performance.now()); let l;
    if (Va) u = await Ut(i, a, s, n); else try { u = await Ut(i, a, s, n) } catch (p) {
        // TRADUÇÃO HOLOLAB
        console.error(`Criação do pacote falhou!\n${p}`), p instanceof ze || (l = p), p instanceof DOMException || console.debug(pe(p).join(`
`))
    }
    if (o.classList.add("finished"), u) {
        o.dataset.translate = "download", o.classList.add("completed"); let p = !1; o.onclick = () => {
            // MODIFICADO POR HOLOLAB: Referência ao Supabase precisa ser revista se você não for usar
            !p && Da && (Ua ??= new Ye(Dr, Ur), Ua.recordPackCreation(i), p = !0), Fe(u, u.name)
        }
    } else if (l) {
        let p = document.createElement("a"); p.classList.add("buttonlike", "packInfoButton", "reportIssue"),
            // ATENÇÃO: Link do GitHub para reportar issues precisa ser seu
            p.href = `https://github.com/SuperLlama88888/holoprint/issues/new?template=1-pack-creation-error.yml&title=Erro na criação do pacote: ${encodeURIComponent(l.toString().replaceAll(`\n`, " "))}&version=${dt}&logs=${encodeURIComponent(JSON.stringify(B("simple-logger").allLogs))}`,
            p.target = "_blank", p.dataset.translate = "pack_generation_failed.report_github_issue", o.parentNode.replaceChild(p, o)
    } else o.classList.add("failed"), o.dataset.translate = "pack_generation_failed"; Gt.disabled = !1
}
//# sourceMappingURL=index.js.map
